"use strict";(self.webpackChunkopen_catalogi_docs=self.webpackChunkopen_catalogi_docs||[]).push([[862],{17404:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>$,frontMatter:()=>a,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"fixes/fix_saveObjects_inversedBy","title":"Fix voor saveObjects inversedBy relaties","description":"Probleem","source":"@site/docs/fixes/fix_saveObjects_inversedBy.md","sourceDirName":"fixes","slug":"/fixes/fix_saveObjects_inversedBy","permalink":"/docs/fixes/fix_saveObjects_inversedBy","draft":false,"unlisted":false,"editUrl":"https://github.com/conductionnl/openregister/tree/main/website/docs/fixes/fix_saveObjects_inversedBy.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"WriteBack Configuration Refactoring TODO","permalink":"/docs/fixes/WRITEBACK_CONFIGURATION_TODO"},"next":{"title":"Introduction","permalink":"/docs/"}}');var s=r(74848),i=r(28453);const a={},o="Fix voor saveObjects inversedBy relaties",c={},l=[{value:"Probleem",id:"probleem",level:2},{value:"Hoofdproblemen:",id:"hoofdproblemen",level:2},{value:"Oplossing",id:"oplossing",level:2},{value:"1. Verbeter prepareObjectsForBulkSave methode",id:"1-verbeter-prepareobjectsforbulksave-methode",level:3},{value:"2. Verbeter handleBulkInverseRelations om ook zonder writeBack te werken",id:"2-verbeter-handlebulkinverserelations-om-ook-zonder-writeback-te-werken",level:3},{value:"3. Voeg writeBack verwerking toe na bulk save",id:"3-voeg-writeback-verwerking-toe-na-bulk-save",level:3},{value:"Implementatie Plan",id:"implementatie-plan",level:2},{value:"Test Plan",id:"test-plan",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"fix-voor-saveobjects-inversedby-relaties",children:"Fix voor saveObjects inversedBy relaties"})}),"\n",(0,s.jsx)(n.h2,{id:"probleem",children:"Probleem"}),"\n",(0,s.jsxs)(n.p,{children:["De ",(0,s.jsx)(n.code,{children:"saveObjects"})," methode in ",(0,s.jsx)(n.code,{children:"ObjectService.php"})," verwerkt inversedBy relaties niet correct tijdens bulk imports."]}),"\n",(0,s.jsx)(n.h2,{id:"hoofdproblemen",children:"Hoofdproblemen:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prepareObjectsForBulkSave"})," doet niets (regel 2723-2725)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"handleBulkInverseRelations"})," wordt nooit aangeroepen"]}),"\n",(0,s.jsx)(n.li,{children:"Geen pre-validatie cascading voor bulk operaties"}),"\n",(0,s.jsx)(n.li,{children:"Geen writeBack verwerking"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"oplossing",children:"Oplossing"}),"\n",(0,s.jsx)(n.h3,{id:"1-verbeter-prepareobjectsforbulksave-methode",children:"1. Verbeter prepareObjectsForBulkSave methode"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"private function prepareObjectsForBulkSave(array $objects): array\n{\n    $startTime = microtime(true);\n    $objectCount = count($objects);\n    \n    $this->logger->debug('Starting bulk preparation', ['objectCount' => $objectCount]);\n\n    if (empty($objects)) {\n        return [];\n    }\n\n    $preparedObjects = [];\n    $schemaCache = [];\n    \n    // Pre-process objects for inversedBy relationships\n    foreach ($objects as $index => $object) {\n        try {\n            $selfData = $object['@self'] ?? [];\n            $schemaId = $selfData['schema'] ?? null;\n            \n            if (!$schemaId) {\n                $preparedObjects[$index] = $object;\n                continue;\n            }\n            \n            // Cache schemas to avoid repeated database calls\n            if (!isset($schemaCache[$schemaId])) {\n                try {\n                    $schemaCache[$schemaId] = $this->schemaMapper->find($schemaId);\n                } catch (\\Exception $e) {\n                    $preparedObjects[$index] = $object;\n                    continue;\n                }\n            }\n            \n            $schema = $schemaCache[$schemaId];\n            \n            // Generate UUID if not present\n            if (!isset($selfData['id']) || empty($selfData['id'])) {\n                $selfData['id'] = \\Symfony\\Component\\Uid\\Uuid::v4()->toRfc4122();\n                $object['@self'] = $selfData;\n            }\n            \n            // Handle pre-validation cascading for inversedBy properties\n            [$processedObject, $uuid] = $this->handlePreValidationCascading($object, $schema, $selfData['id']);\n            \n            $preparedObjects[$index] = $processedObject;\n            \n        } catch (\\Exception $e) {\n            $this->logger->error('Error preparing object for bulk save', [\n                'index' => $index,\n                'error' => $e->getMessage()\n            ]);\n            $preparedObjects[$index] = $object; // Continue with original object\n        }\n    }\n\n    // Handle bulk inverse relations within the batch\n    $this->handleBulkInverseRelations($preparedObjects, $schemaCache);\n\n    $endTime = microtime(true);\n    $duration = round(($endTime - $startTime) * 1000, 2);\n    $successCount = count($preparedObjects);\n    \n    $this->logger->debug('Bulk preparation completed', [\n        'successCount' => $successCount,\n        'duration' => $duration,\n        'unit' => 'ms'\n    ]);\n\n    return array_values($preparedObjects);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-verbeter-handlebulkinverserelations-om-ook-zonder-writeback-te-werken",children:"2. Verbeter handleBulkInverseRelations om ook zonder writeBack te werken"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"private function handleBulkInverseRelations(array &$preparedObjects, array $schemaCache): void\n{\n    $inverseRelationMap = [];\n    $processedCount = 0;\n\n    // Build inverse relation map by scanning all objects\n    foreach ($preparedObjects as $index => $object) {\n        $selfData = $object['@self'] ?? [];\n        $schemaId = $selfData['schema'] ?? null;\n        $objectUuid = $selfData['id'] ?? null;\n\n        if (!$schemaId || !$objectUuid || !isset($schemaCache[$schemaId])) {\n            continue;\n        }\n\n        $schema = $schemaCache[$schemaId];\n        $schemaProperties = $schema->getProperties();\n\n        // Scan each property for inverse relations\n        foreach ($object as $property => $value) {\n            if ($property === '@self' || !isset($schemaProperties[$property])) {\n                continue;\n            }\n\n            $propertyConfig = $schemaProperties[$property];\n            $items = $propertyConfig['items'] ?? [];\n            \n            // Check for inversedBy at property level (single object relations)\n            $inversedBy = $propertyConfig['inversedBy'] ?? null;\n            $writeBack = $propertyConfig['writeBack'] ?? false;\n            \n            // Check for inversedBy in array items (array of object relations)\n            if (!$inversedBy && isset($items['inversedBy'])) {\n                $inversedBy = $items['inversedBy'];\n                $writeBack = $items['writeBack'] ?? false;\n            }\n\n            // Process if this property has inverse relations (writeBack not required for bulk)\n            if ($inversedBy) {\n                // Handle single object relations\n                if (!is_array($value) && is_string($value) && \\Symfony\\Component\\Uid\\Uuid::isValid($value)) {\n                    if (!isset($inverseRelationMap[$value])) {\n                        $inverseRelationMap[$value] = [];\n                    }\n                    if (!isset($inverseRelationMap[$value][$inversedBy])) {\n                        $inverseRelationMap[$value][$inversedBy] = [];\n                    }\n                    $inverseRelationMap[$value][$inversedBy][] = $objectUuid;\n                    $processedCount++;\n                }\n                // Handle array of object relations\n                elseif (is_array($value)) {\n                    foreach ($value as $relatedUuid) {\n                        if (is_string($relatedUuid) && \\Symfony\\Component\\Uid\\Uuid::isValid($relatedUuid)) {\n                            if (!isset($inverseRelationMap[$relatedUuid])) {\n                                $inverseRelationMap[$relatedUuid] = [];\n                            }\n                            if (!isset($inverseRelationMap[$relatedUuid][$inversedBy])) {\n                                $inverseRelationMap[$relatedUuid][$inversedBy] = [];\n                            }\n                            $inverseRelationMap[$relatedUuid][$inversedBy][] = $objectUuid;\n                            $processedCount++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    $this->logger->debug('Processing inverse relations', [\n        'processedCount' => $processedCount,\n        'targetObjects' => count($inverseRelationMap)\n    ]);\n\n    // Apply inverse relations back to objects in the current batch\n    $appliedCount = 0;\n    foreach ($preparedObjects as $index => &$object) {\n        $selfData = $object['@self'] ?? [];\n        $objectUuid = $selfData['id'] ?? null;\n\n        if ($objectUuid && isset($inverseRelationMap[$objectUuid])) {\n            foreach ($inverseRelationMap[$objectUuid] as $property => $relatedUuids) {\n                // Merge with existing values if any, ensuring uniqueness\n                $existingValues = $object[$property] ?? [];\n                if (!is_array($existingValues)) {\n                    $existingValues = [];\n                }\n                $object[$property] = array_values(array_unique(array_merge($existingValues, $relatedUuids)));\n                $appliedCount++;\n            }\n        }\n    }\n\n    $this->logger->debug('Applied inverse relation updates', [\n        'appliedCount' => $appliedCount\n    ]);\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-voeg-writeback-verwerking-toe-na-bulk-save",children:"3. Voeg writeBack verwerking toe na bulk save"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-php",children:"private function handlePostSaveInverseRelations(array $savedObjects, array $schemaCache): void\n{\n    $writeBackCount = 0;\n    \n    foreach ($savedObjects as $savedObject) {\n        $objectData = $savedObject->getObject();\n        $schemaId = $savedObject->getSchema();\n        \n        if (!isset($schemaCache[$schemaId])) {\n            continue;\n        }\n        \n        $schema = $schemaCache[$schemaId];\n        $schemaProperties = $schema->getProperties();\n        \n        foreach ($objectData as $property => $value) {\n            if (!isset($schemaProperties[$property])) {\n                continue;\n            }\n            \n            $propertyConfig = $schemaProperties[$property];\n            $items = $propertyConfig['items'] ?? [];\n            \n            // Check for writeBack enabled properties\n            $writeBack = $propertyConfig['writeBack'] ?? ($items['writeBack'] ?? false);\n            $inversedBy = $propertyConfig['inversedBy'] ?? ($items['inversedBy'] ?? null);\n            \n            if ($writeBack && $inversedBy && !empty($value)) {\n                // Use SaveObject handler's writeBack functionality\n                try {\n                    $this->saveHandler->handleInverseRelationsWriteBack($savedObject, $schema, $objectData);\n                    $writeBackCount++;\n                } catch (\\Exception $e) {\n                    $this->logger->error('WriteBack failed for object', [\n                        'objectUuid' => $savedObject->getUuid(),\n                        'error' => $e->getMessage()\n                    ]);\n                }\n            }\n        }\n    }\n    \n    $this->logger->debug('Processed writeBack operations', [\n        'writeBackCount' => $writeBackCount\n    ]);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"implementatie-plan",children:"Implementatie Plan"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.strong,{children:["Vervang de huidige ",(0,s.jsx)(n.code,{children:"prepareObjectsForBulkSave"})," methode"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.strong,{children:["Update ",(0,s.jsx)(n.code,{children:"handleBulkInverseRelations"})," om zonder writeBack te werken"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Voeg post-save writeBack verwerking toe"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Roep de nieuwe methodes aan in de juiste volgorde"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"test-plan",children:"Test Plan"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Import organisatie.csv met deelnemers relaties"}),"\n",(0,s.jsx)(n.li,{children:"Controleer of inversedBy relaties correct worden aangemaakt"}),"\n",(0,s.jsx)(n.li,{children:"Verificeer dat writeBack operaties correct werken"}),"\n",(0,s.jsx)(n.li,{children:"Test performance met grote datasets"}),"\n"]})]})}function $(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(96540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);