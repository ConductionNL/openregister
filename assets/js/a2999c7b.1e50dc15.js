"use strict";(self.webpackChunkopen_catalogi_docs=self.webpackChunkopen_catalogi_docs||[]).push([[8167],{11145:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"development/testing","title":"Testing Improvements","description":"The Problem","source":"@site/docs/development/testing.md","sourceDirName":"development","slug":"/development/testing","permalink":"/docs/development/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/conductionnl/openregister/tree/main/website/docs/development/testing.md","tags":[],"version":"current","sidebarPosition":60,"frontMatter":{"title":"Testing Improvements","sidebar_position":60},"sidebar":"tutorialSidebar","previous":{"title":"Monitoring & Testing Implementation","permalink":"/docs/development/monitoring-testing"},"next":{"title":"OpenAPI Specification Validation","permalink":"/docs/development/api-validation"}}');var i=s(74848),r=s(28453);const l={title:"Testing Improvements",sidebar_position:60},o="Testing Improvements - Lessons Learned",c={},d=[{value:"The Problem",id:"the-problem",level:2},{value:"Root Cause Analysis",id:"root-cause-analysis",level:2},{value:"The Fix",id:"the-fix",level:2},{value:"Testing Improvements Implemented",id:"testing-improvements-implemented",level:2},{value:"1. Integration Tests (<code>tests/Integration/SolrApiIntegrationTest.php</code>)",id:"1-integration-tests-testsintegrationsolrapiintegrationtestphp",level:3},{value:"2. Controller Unit Tests (<code>tests/Unit/Controller/SettingsControllerTest.php</code>)",id:"2-controller-unit-tests-testsunitcontrollersettingscontrollertestphp",level:3},{value:"What These Tests Catch",id:"what-these-tests-catch",level:2},{value:"\u2705 <strong>Issues These Tests WOULD Have Caught:</strong>",id:"-issues-these-tests-would-have-caught",level:3},{value:"\u2705 <strong>Additional Benefits:</strong>",id:"-additional-benefits",level:3},{value:"Best Practices Established",id:"best-practices-established",level:2},{value:"1. <strong>Always Test HTTP Client Integration</strong>",id:"1-always-test-http-client-integration",level:3},{value:"2. <strong>Test Exception Handling in Controllers</strong>",id:"2-test-exception-handling-in-controllers",level:3},{value:"3. <strong>Validate Response Structure</strong>",id:"3-validate-response-structure",level:3},{value:"4. <strong>Test Type Casting Edge Cases</strong>",id:"4-test-type-casting-edge-cases",level:3},{value:"Running the Tests",id:"running-the-tests",level:2},{value:"Future Improvements",id:"future-improvements",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Related Documentation",id:"related-documentation",level:2}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"testing-improvements---lessons-learned",children:"Testing Improvements - Lessons Learned"})}),"\n",(0,i.jsx)(n.h2,{id:"the-problem",children:"The Problem"}),"\n",(0,i.jsx)(n.p,{children:"On September 15, 2024, we encountered a critical bug in production:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"json_decode(): Argument #1 ($json) must be of type string, \nGuzzleHttp\\Psr7\\Stream given in file 'lib/Service/GuzzleSolrService.php' line 2231\n"})}),"\n",(0,i.jsx)(n.p,{children:"This bug occurred when we switched from Nextcloud's HTTP client to a direct Guzzle client to bypass local access restrictions. The bug caused HTTP 500 errors on the SOLR connection test API endpoint."}),"\n",(0,i.jsx)(n.h2,{id:"root-cause-analysis",children:"Root Cause Analysis"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Why this bug occurred:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Architectural Change"}),": We switched from ",(0,i.jsx)(n.code,{children:"IClientService"})," to direct ",(0,i.jsx)(n.code,{children:"GuzzleHttp\\Client"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Type Difference"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Nextcloud HTTP Client: ",(0,i.jsx)(n.code,{children:"$response->getBody()"})," returns a ",(0,i.jsx)(n.code,{children:"string"})]}),"\n",(0,i.jsxs)(n.li,{children:["Direct Guzzle Client: ",(0,i.jsx)(n.code,{children:"$response->getBody()"})," returns a ",(0,i.jsx)(n.code,{children:"GuzzleHttp\\Psr7\\Stream"})," object"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Missing Type Casting"}),": Our code assumed ",(0,i.jsx)(n.code,{children:"getBody()"})," always returned a string"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Insufficient Testing"}),": No tests validated HTTP client response handling"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-fix",children:"The Fix"}),"\n",(0,i.jsx)(n.p,{children:"We fixed the issue by casting all response bodies to strings:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// BEFORE (causing TypeError):\n$data = json_decode($response->getBody(), true);\n\n// AFTER (fixed):\n$data = json_decode((string)$response->getBody(), true);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Files Updated:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Fixed 12 instances in ",(0,i.jsx)(n.code,{children:"lib/Service/GuzzleSolrService.php"})]}),"\n",(0,i.jsx)(n.li,{children:"All methods that parse JSON responses now properly cast response bodies"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"testing-improvements-implemented",children:"Testing Improvements Implemented"}),"\n",(0,i.jsxs)(n.h3,{id:"1-integration-tests-testsintegrationsolrapiintegrationtestphp",children:["1. Integration Tests (",(0,i.jsx)(n.code,{children:"tests/Integration/SolrApiIntegrationTest.php"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mock HTTP Responses"}),": Uses Guzzle's ",(0,i.jsx)(n.code,{children:"MockHandler"})," to simulate real HTTP responses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Stream Bug Reproduction"}),": Specifically tests the scenario that caused our bug"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Type Validation"}),": Ensures all methods handle Stream objects correctly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exception Detection"}),": Catches ",(0,i.jsx)(n.code,{children:"TypeError"})," exceptions related to ",(0,i.jsx)(n.code,{children:"json_decode()"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Critical Test:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"public function testJsonDecodeStreamBugIsFixed(): void\n{\n    // Create a Stream object (what Guzzle returns)\n    $stream = \\GuzzleHttp\\Psr7\\Utils::streamFor($jsonString);\n    $mockResponse = new Response(200, [], $stream);\n    \n    // This test would FAIL before our fix and PASS after\n    $result = $this->guzzleSolrService->testConnection();\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-controller-unit-tests-testsunitcontrollersettingscontrollertestphp",children:["2. Controller Unit Tests (",(0,i.jsx)(n.code,{children:"tests/Unit/Controller/SettingsControllerTest.php"}),")"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Key Features:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Comprehensive Coverage"}),": Tests ALL 25+ SettingsController endpoints"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Response Validation"}),": Ensures all endpoints return proper ",(0,i.jsx)(n.code,{children:"JSONResponse"})," objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Exception Handling"}),": Tests that controller gracefully handles service exceptions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"JSON Structure Validation"}),": Validates response structure and required fields"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Serialization Testing"}),": Ensures response data is JSON-encodable"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Endpoints Covered:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"SOLR"}),": ",(0,i.jsx)(n.code,{children:"testSolrConnection"}),", ",(0,i.jsx)(n.code,{children:"setupSolr"}),", ",(0,i.jsx)(n.code,{children:"testSolrSetup"}),", ",(0,i.jsx)(n.code,{children:"getSolrSettings"}),", ",(0,i.jsx)(n.code,{children:"updateSolrSettings"}),", ",(0,i.jsx)(n.code,{children:"getSolrDashboardStats"}),", ",(0,i.jsx)(n.code,{children:"warmupSolrIndex"}),", ",(0,i.jsx)(n.code,{children:"testSchemaMapping"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache"}),": ",(0,i.jsx)(n.code,{children:"getCacheStats"}),", ",(0,i.jsx)(n.code,{children:"clearCache"}),", ",(0,i.jsx)(n.code,{children:"warmupNamesCache"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"RBAC"}),": ",(0,i.jsx)(n.code,{children:"getRbacSettings"}),", ",(0,i.jsx)(n.code,{children:"updateRbacSettings"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Multitenancy"}),": ",(0,i.jsx)(n.code,{children:"getMultitenancySettings"}),", ",(0,i.jsx)(n.code,{children:"updateMultitenancySettings"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Retention"}),": ",(0,i.jsx)(n.code,{children:"getRetentionSettings"}),", ",(0,i.jsx)(n.code,{children:"updateRetentionSettings"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Core"}),": ",(0,i.jsx)(n.code,{children:"load"}),", ",(0,i.jsx)(n.code,{children:"update"}),", ",(0,i.jsx)(n.code,{children:"updatePublishingOptions"}),", ",(0,i.jsx)(n.code,{children:"rebase"}),", ",(0,i.jsx)(n.code,{children:"stats"}),", ",(0,i.jsx)(n.code,{children:"getStatistics"}),", ",(0,i.jsx)(n.code,{children:"getVersionInfo"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Critical Tests:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// Exception handling test\npublic function testSolrConnectionTestHandlesServiceExceptions(): void\n{\n    // Mock service throwing our exact bug\n    $this->settingsService\n        ->method('testSolrConnection')\n        ->willThrowException(new \\TypeError('json_decode(): Argument #1...'));\n    \n    // Controller should return valid JSON, not crash\n    $response = $this->controller->testSolrConnection();\n    $this->assertInstanceOf(JSONResponse::class, $response);\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"what-these-tests-catch",children:"What These Tests Catch"}),"\n",(0,i.jsxs)(n.h3,{id:"-issues-these-tests-would-have-caught",children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Issues These Tests WOULD Have Caught:"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"json_decode Type Errors"}),": Direct detection of Stream vs string issues"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HTTP Client Changes"}),": Any breaking changes when switching HTTP clients"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Parsing Failures"}),": Invalid JSON handling, malformed responses"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Controller Exception Handling"}),": Unhandled service exceptions causing crashes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Response Structure"}),": Missing required fields, wrong data types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"URL Building Issues"}),": Port 0 problems, Kubernetes service name handling"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Reporting Regressions"}),": Missing error details, generic messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Configuration Edge Cases"}),": Various hostname/port combinations"]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"-additional-benefits",children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Additional Benefits:"})]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Regression Prevention"}),": Future HTTP client changes won't break existing functionality"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Tests serve as living documentation of expected behavior"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Confidence"}),": Developers can refactor knowing tests will catch breaking changes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debugging"}),": Failed tests provide specific error context"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices-established",children:"Best Practices Established"}),"\n",(0,i.jsxs)(n.h3,{id:"1-always-test-http-client-integration",children:["1. ",(0,i.jsx)(n.strong,{children:"Always Test HTTP Client Integration"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// Mock different HTTP client behaviors\n$mockHandler = new MockHandler([\n    new Response(200, [], $jsonStream),  // Stream response\n    new Response(500, [], $errorString), // String response\n    new Response(404, [], 'Not Found'),  // Plain text\n]);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"2-test-exception-handling-in-controllers",children:["2. ",(0,i.jsx)(n.strong,{children:"Test Exception Handling in Controllers"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// Ensure controllers handle service exceptions gracefully\n$this->settingsService->method('testSolrConnection')\n    ->willThrowException(new \\TypeError('...'));\n    \n$response = $this->controller->testSolrConnection();\n$this->assertInstanceOf(JSONResponse::class, $response);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"3-validate-response-structure",children:["3. ",(0,i.jsx)(n.strong,{children:"Validate Response Structure"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// Ensure API responses are consistent\n$data = $response->getData();\n$this->assertArrayHasKey('success', $data);\n$this->assertArrayHasKey('message', $data);\n$this->assertIsBool($data['success']);\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"4-test-type-casting-edge-cases",children:["4. ",(0,i.jsx)(n.strong,{children:"Test Type Casting Edge Cases"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-php",children:"// Test that response body casting works correctly\n$stream = \\GuzzleHttp\\Psr7\\Utils::streamFor($jsonString);\n$result = json_decode((string)$stream->getBody(), true);\n$this->assertIsArray($result);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"running-the-tests",children:"Running the Tests"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Run all tests\n./vendor/bin/phpunit\n\n# Run specific test suites\n./vendor/bin/phpunit tests/Integration/SolrApiIntegrationTest.php --testdox\n./vendor/bin/phpunit tests/Unit/Controller/SettingsControllerTest.php --testdox\n\n# Run with coverage\n./vendor/bin/phpunit --coverage-html coverage/\n"})}),"\n",(0,i.jsx)(n.h2,{id:"future-improvements",children:"Future Improvements"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-commit Hooks"}),": Automatically run these tests before commits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CI/CD Integration"}),": Include these tests in automated pipelines"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance Testing"}),": Add tests for response time and memory usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Scenario Coverage"}),": Test more edge cases and failure modes"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"This bug taught us the critical importance of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing architectural changes"})," thoroughly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Understanding HTTP client differences"})," between libraries"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implementing comprehensive integration tests"})," for external dependencies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validating assumptions"})," about third-party library behavior"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The tests we've implemented will prevent similar issues in the future and provide confidence when making changes to HTTP client implementations."}),"\n",(0,i.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/development/monitoring-testing",children:"Monitoring & Testing"})," - Monitoring infrastructure"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"/docs/development/file-uploads-implementation",children:"File Uploads Implementation"})," - File upload testing strategy"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function l(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);