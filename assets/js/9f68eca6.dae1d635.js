"use strict";(self.webpackChunkopen_catalogi_docs=self.webpackChunkopen_catalogi_docs||[]).push([[3641],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>c});var i=s(96540);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},72879:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Features/faceting","title":"Comprehensive Faceting System","description":"This document describes the new Elasticsearch-inspired faceting system implemented for the OpenRegister application. The system provides powerful, flexible faceting capabilities that support both metadata and object field facets with enumerated values and range buckets.","source":"@site/docs/Features/faceting.md","sourceDirName":"Features","slug":"/Features/faceting","permalink":"/docs/Features/faceting","draft":false,"unlisted":false,"editUrl":"https://github.com/conductionnl/openregister/tree/main/website/docs/Features/faceting.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Configurations","permalink":"/docs/Features/configurations"},"next":{"title":"Multi-Tenancy","permalink":"/docs/Features/multi-tenancy"}}');var t=s(74848),a=s(28453);const r={},c="Comprehensive Faceting System",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"1. Disjunctive Faceting",id:"1-disjunctive-faceting",level:3},{value:"2. Multiple Facet Types",id:"2-multiple-facet-types",level:3},{value:"3. Dual Data Sources",id:"3-dual-data-sources",level:3},{value:"4. Enhanced Labels with Caching",id:"4-enhanced-labels-with-caching",level:3},{value:"UUID Resolution Technical Implementation",id:"uuid-resolution-technical-implementation",level:4},{value:"5. Facetable Field Discovery",id:"5-facetable-field-discovery",level:3},{value:"Facetable Field Discovery",id:"facetable-field-discovery",level:2},{value:"Discovery API",id:"discovery-api",level:3},{value:"Discovery Response Structure",id:"discovery-response-structure",level:3},{value:"Field Properties Explained",id:"field-properties-explained",level:3},{value:"Key Terms",id:"key-terms",level:4},{value:"Field Types and Characteristics",id:"field-types-and-characteristics",level:3},{value:"Metadata Fields (@self)",id:"metadata-fields-self",level:4},{value:"Object Fields",id:"object-fields",level:4},{value:"Discovery Configuration",id:"discovery-configuration",level:3},{value:"Field Analysis Parameters",id:"field-analysis-parameters",level:4},{value:"Field Filtering",id:"field-filtering",level:4},{value:"API Integration",id:"api-integration",level:3},{value:"Discovery Parameter",id:"discovery-parameter",level:4},{value:"Dynamic Facet Configuration",id:"dynamic-facet-configuration",level:4},{value:"API Structure",id:"api-structure",level:2},{value:"Basic Query Structure",id:"basic-query-structure",level:3},{value:"Response Structure",id:"response-structure",level:3},{value:"Facet Types",id:"facet-types",level:2},{value:"1. Terms Aggregation",id:"1-terms-aggregation",level:3},{value:"2. Date Histogram",id:"2-date-histogram",level:3},{value:"3. Range Aggregation",id:"3-range-aggregation",level:3},{value:"Usage Examples",id:"usage-examples",level:2},{value:"Basic Enumerated Facets",id:"basic-enumerated-facets",level:3},{value:"Date Timeline Facets",id:"date-timeline-facets",level:3},{value:"Price Range Facets",id:"price-range-facets",level:3},{value:"Integration with Search",id:"integration-with-search",level:2},{value:"Combined Search and Facets",id:"combined-search-and-facets",level:3},{value:"Disjunctive Faceting Example",id:"disjunctive-faceting-example",level:3},{value:"Schema-Based Facet Configuration",id:"schema-based-facet-configuration",level:2},{value:"Schema Property Configuration",id:"schema-property-configuration",level:3},{value:"Automatic Facet Type Detection",id:"automatic-facet-type-detection",level:3},{value:"Schema-Based Discovery Benefits",id:"schema-based-discovery-benefits",level:3},{value:"Backend Implementation",id:"backend-implementation",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Performance Impact",id:"performance-impact",level:3},{value:"Asynchronous Operations",id:"asynchronous-operations",level:3},{value:"Performance Benefits",id:"performance-benefits",level:4},{value:"Available Methods",id:"available-methods",level:4},{value:"Usage Examples",id:"usage-examples-1",level:4},{value:"When to Use Async Methods",id:"when-to-use-async-methods",level:4},{value:"Optimizations",id:"optimizations",level:3},{value:"Database Index Optimization",id:"database-index-optimization",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Migration from Legacy System",id:"migration-from-legacy-system",level:2},{value:"Old Approach",id:"old-approach",level:3},{value:"New Approach",id:"new-approach",level:3},{value:"Backward Compatibility",id:"backward-compatibility",level:3},{value:"UI Integration Examples",id:"ui-integration-examples",level:2},{value:"Dynamic Facet Discovery",id:"dynamic-facet-discovery",level:3},{value:"Enhanced Facet Component",id:"enhanced-facet-component",level:3},{value:"PHP Controller Example",id:"php-controller-example",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit Test Examples",id:"unit-test-examples",level:3},{value:"Caching and Label Resolution",id:"caching-and-label-resolution",level:2},{value:"Overview",id:"overview-1",level:3},{value:"How It Works",id:"how-it-works",level:3},{value:"Label Resolution Process",id:"label-resolution-process",level:4},{value:"Example Response",id:"example-response",level:4},{value:"Sorting Behavior",id:"sorting-behavior",level:4},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Static Caching (SaveObjects)",id:"static-caching-saveobjects",level:4},{value:"Entity Caching (ObjectService)",id:"entity-caching-objectservice",level:4},{value:"Mapper Optimizations",id:"mapper-optimizations",level:4},{value:"UUID Resolution for Object Field Facets",id:"uuid-resolution-for-object-field-facets",level:4},{value:"Performance Benefits",id:"performance-benefits-1",level:3},{value:"Without Caching",id:"without-caching",level:4},{value:"With Caching",id:"with-caching",level:4},{value:"Real-World Impact",id:"real-world-impact",level:4},{value:"Implementation Details",id:"implementation-details",level:3},{value:"Facet Processing Pipeline",id:"facet-processing-pipeline",level:4},{value:"Code Flow Diagram",id:"code-flow-diagram",level:4},{value:"Which Fields Get Label Resolution",id:"which-fields-get-label-resolution",level:4},{value:"Configuration",id:"configuration",level:3},{value:"Facet Bucket Limits",id:"facet-bucket-limits",level:4},{value:"Disabling Caching",id:"disabling-caching",level:4},{value:"Customizing Label Format",id:"customizing-label-format",level:4},{value:"Troubleshooting",id:"troubleshooting",level:3},{value:"Labels Showing as IDs",id:"labels-showing-as-ids",level:4},{value:"Performance Issues",id:"performance-issues",level:4},{value:"Cache Invalidation",id:"cache-invalidation",level:4},{value:"Conclusion",id:"conclusion",level:2},{value:"Facetable Discovery Benefits",id:"facetable-discovery-benefits",level:3},{value:"Usage Recommendations",id:"usage-recommendations",level:3},{value:"Technical Architecture",id:"technical-architecture",level:2},{value:"Faceting Request Flow",id:"faceting-request-flow",level:3},{value:"Facet Processing Pipeline",id:"facet-processing-pipeline-1",level:3},{value:"UUID Resolution Process",id:"uuid-resolution-process",level:3},{value:"Disjunctive Faceting Implementation",id:"disjunctive-faceting-implementation",level:3},{value:"Facet Type Selection Logic",id:"facet-type-selection-logic",level:3},{value:"Caching Strategy",id:"caching-strategy-1",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"Code Examples",id:"code-examples",level:3},{value:"Building Custom Facet Query",id:"building-custom-facet-query",level:4},{value:"Processing Facet Results",id:"processing-facet-results",level:4},{value:"Testing",id:"testing-1",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"comprehensive-faceting-system",children:"Comprehensive Faceting System"})}),"\n",(0,t.jsx)(n.p,{children:"This document describes the new Elasticsearch-inspired faceting system implemented for the OpenRegister application. The system provides powerful, flexible faceting capabilities that support both metadata and object field facets with enumerated values and range buckets."}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The faceting system provides a modern, user-friendly approach to building faceted search interfaces. It supports:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Disjunctive faceting"})," - Facet options don't disappear when selected"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multiple facet types"})," - Terms, date histograms, and numeric ranges"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Metadata and object field facets"})," - Both table columns and JSON data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Facetable field discovery"})," - Automatic detection of available faceting options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Elasticsearch-style API"})," - Familiar structure for developers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance optimization"})," - Efficient database queries with proper indexing"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,t.jsx)(n.h3,{id:"1-disjunctive-faceting",children:"1. Disjunctive Faceting"}),"\n",(0,t.jsx)(n.p,{children:"Each facet shows counts as if its own filter were not applied. This prevents facet options from disappearing when selected, providing a better user experience."}),"\n",(0,t.jsx)(n.h3,{id:"2-multiple-facet-types",children:"2. Multiple Facet Types"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Terms aggregation"})," - For categorical data (status, priority, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Date histogram"})," - For time-based data with configurable intervals"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Range aggregation"})," - For numeric data with custom buckets"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-dual-data-sources",children:"3. Dual Data Sources"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Metadata facets"})," - Based on ObjectEntity table columns (@self)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Object field facets"})," - Based on JSON object data"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"4-enhanced-labels-with-caching",children:"4. Enhanced Labels with Caching"}),"\n",(0,t.jsx)(n.p,{children:"Automatic resolution of register, schema, organisation IDs, and object UUIDs to human-readable names using an optimized caching mechanism. The system intelligently detects UUIDs in any facet and resolves them to object names (naam, name, title, etc.) using batch loading and multi-tier caching. Facet buckets are automatically sorted alphabetically by label for consistent, user-friendly display."}),"\n",(0,t.jsx)(n.h4,{id:"uuid-resolution-technical-implementation",children:"UUID Resolution Technical Implementation"}),"\n",(0,t.jsx)(n.p,{children:"The faceting system includes intelligent UUID-to-name resolution that works automatically:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Resolution Process:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UUID Detection"})," - Identifies bucket values containing hyphens (UUID format)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lazy Service Loading"})," - ObjectCacheService loaded from container only when needed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch Resolution"})," - All UUIDs in facets resolved in a single database query"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-Tier Caching"})," - Checks in-memory cache \u2192 distributed cache \u2192 database"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Name Extraction"})," - Searches common name fields (naam, name, title, contractNummer, achternaam)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Alphabetical Sorting"})," - Facets sorted by resolved labels (case-insensitive A-Z)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graceful Fallback"})," - Uses UUID if name cannot be resolved"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example Transformation:"})}),"\n",(0,t.jsx)(n.p,{children:"Before UUID resolution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:"{\n  'value': '01c26b42-e047-4322-95ba-46d53a1696c0',\n  'count': 2,\n  'label': '01c26b42-e047-4322-95ba-46d53a1696c0'\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"After UUID resolution:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:"{\n  'value': '01c26b42-e047-4322-95ba-46d53a1696c0',\n  'count': 2,\n  'label': 'Component Name Here'\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Performance Characteristics:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch queries"}),": All UUIDs resolved in one DB query (no N+1 problem)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cached"}),": <10ms for cached names"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Uncached"}),": <100ms for 100 UUIDs (batch DB query)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lazy loading"}),": Service only loaded when facets contain UUIDs"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Service Integration:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Lazy-loading pattern to avoid circular dependencies\nprivate function getObjectCacheService(): ?ObjectCacheService\n{\n    if ($this->objectCacheServiceAttempted) {\n        return $this->objectCacheService;\n    }\n    \n    $this->objectCacheServiceAttempted = true;\n    \n    try {\n        $this->objectCacheService = \\OC::$server->get(ObjectCacheService::class);\n        $this->logger->debug('ObjectCacheService loaded successfully');\n    } catch (\\Exception $e) {\n        $this->logger->warning('ObjectCacheService not available for UUID resolution', [\n            'error' => $e->getMessage()\n        ]);\n        return null;\n    }\n    \n    return $this->objectCacheService;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This ensures the service is only loaded when facets containing UUIDs are encountered, avoiding performance overhead for regular facets."}),"\n",(0,t.jsx)(n.h3,{id:"5-facetable-field-discovery",children:"5. Facetable Field Discovery"}),"\n",(0,t.jsx)(n.p,{children:"Automatic analysis of available fields and their characteristics to help frontends build dynamic facet interfaces."}),"\n",(0,t.jsx)(n.h2,{id:"facetable-field-discovery",children:"Facetable Field Discovery"}),"\n",(0,t.jsx)(n.p,{children:"The system includes powerful discovery capabilities that analyze your data to determine which fields can be used for faceting and what types of facets are appropriate."}),"\n",(0,t.jsx)(n.h3,{id:"discovery-api",children:"Discovery API"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Get facetable fields for a specific context\n$facetableFields = $objectService->getFacetableFields($baseQuery, $sampleSize);\n\n// Example with context filters\n$baseQuery = [\n    '@self' => ['register' => 1],\n    '_search' => 'customer'\n];\n\n$facetableFields = $objectService->getFacetableFields($baseQuery, 100);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"discovery-response-structure",children:"Discovery Response Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"[\n    '@self' => [\n        'register' => [\n            'type' => 'categorical',\n            'description' => 'Register that contains the object',\n            'facet_types' => ['terms'],\n            'has_labels' => true,\n            'sample_values' => [\n                ['value' => 1, 'label' => 'Publications Register', 'count' => 150],\n                ['value' => 2, 'label' => 'Events Register', 'count' => 75]\n            ]\n        ],\n        'created' => [\n            'type' => 'date',\n            'description' => 'Date and time when the object was created',\n            'facet_types' => ['date_histogram', 'range'],\n            'intervals' => ['day', 'week', 'month', 'year'],\n            'has_labels' => false,\n            'date_range' => [\n                'min' => '2023-01-01 00:00:00',\n                'max' => '2024-12-31 23:59:59'\n            ]\n        ]\n    ],\n    'object_fields' => [\n        'status' => [\n            'type' => 'string',\n            'description' => 'Object field: status',\n            'facet_types' => ['terms'],\n            'cardinality' => 'low',  // \u226450 unique values\n            'sample_values' => ['published', 'draft', 'archived'],\n            'appearance_rate' => 85  // Count of objects containing this field\n        ],\n        'priority' => [\n            'type' => 'integer',\n            'description' => 'Object field: priority',\n            'facet_types' => ['range', 'terms'],\n            'cardinality' => 'numeric',  // Numeric field type\n            'sample_values' => ['1', '2', '3', '4', '5'],\n            'appearance_rate' => 72  // Count of objects containing this field\n        ]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"field-properties-explained",children:"Field Properties Explained"}),"\n",(0,t.jsx)(n.h4,{id:"key-terms",children:"Key Terms"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"appearance_rate"})}),": The actual count of objects (from the analyzed sample) that contain this field. For example, if 100 objects were analyzed and 85 contained the 'status' field, the appearance_rate would be 85. This is not a percentage but an absolute count."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"cardinality"})}),": Indicates the uniqueness characteristics of field values:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'low'"})," - String fields with \u226450 unique values (suitable for terms facets)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'numeric'"})," - Integer, float, or numeric string fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"'binary'"})," - Boolean fields (true/false values only)"]}),"\n",(0,t.jsx)(n.li,{children:"Not set for date fields (they use intervals instead)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"field-types-and-characteristics",children:"Field Types and Characteristics"}),"\n",(0,t.jsx)(n.h4,{id:"metadata-fields-self",children:"Metadata Fields (@self)"}),"\n",(0,t.jsx)(n.p,{children:"Predefined fields from the ObjectEntity table:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"register"})," - Categorical with labels from register table"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"schema"})," - Categorical with labels from schema table"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"uuid"})," - Identifier field (usually not suitable for faceting)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"owner"})," - Categorical user field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"organisation"})," - Categorical organisation field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"application"})," - Categorical application field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"created/updated/published/depublished"})," - Date fields with range support"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"object-fields",children:"Object Fields"}),"\n",(0,t.jsx)(n.p,{children:"Dynamically discovered from JSON object data:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"string"})," - Text fields (low cardinality suitable for terms facets)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"integer/float"})," - Numeric fields (suitable for range and terms facets)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"date"})," - Date fields (suitable for date_histogram and range facets)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"boolean"})," - Binary fields (suitable for terms facets)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"discovery-configuration",children:"Discovery Configuration"}),"\n",(0,t.jsx)(n.h4,{id:"field-analysis-parameters",children:"Field Analysis Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sample Size"})," - Number of objects to analyze (default: 100)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Appearance Threshold"})," - Minimum percentage of objects that must contain the field (default: 10%)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cardinality Threshold"})," - Maximum unique values for terms facets (default: 50)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Recursion Depth"})," - Maximum nesting level to analyze (default: 2)"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"field-filtering",children:"Field Filtering"}),"\n",(0,t.jsx)(n.p,{children:"The discovery system automatically filters out:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"System fields (starting with @ or _)"}),"\n",(0,t.jsx)(n.li,{children:"Nested objects and arrays of objects"}),"\n",(0,t.jsx)(n.li,{children:"High cardinality string fields (more than 50 unique values)"}),"\n",(0,t.jsx)(n.li,{children:"Fields appearing in less than 10% of objects"}),"\n",(0,t.jsx)(n.li,{children:"Fields with inconsistent types (less than 70% type consistency)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"api-integration",children:"API Integration"}),"\n",(0,t.jsx)(n.h4,{id:"discovery-parameter",children:"Discovery Parameter"}),"\n",(0,t.jsxs)(n.p,{children:["Add ",(0,t.jsx)(n.code,{children:"_facetable=true"})," to any search endpoint to include facetable field information:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"GET /api/objects?_facetable=true&limit=0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Response includes additional ",(0,t.jsx)(n.code,{children:"facetable"})," property:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"[\n    'results' => [],\n    'total' => 0,\n    'facetable' => [\n        '@self' => [...],\n        'object_fields' => [...]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"dynamic-facet-configuration",children:"Dynamic Facet Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Use discovery results to build facet configurations:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// Frontend example: Build facet config from discovery\nconst buildFacetConfig = (facetableFields) => {\n    const config = { _facets: { '@self': {} } };\n    \n    // Add metadata facets\n    Object.entries(facetableFields['@self']).forEach(([field, info]) => {\n        if (info.facet_types.includes('terms')) {\n            config._facets['@self'][field] = { type: 'terms' };\n        } else if (info.facet_types.includes('date_histogram')) {\n            config._facets['@self'][field] = { \n                type: 'date_histogram', \n                interval: 'month' \n            };\n        }\n    });\n    \n    // Add object field facets\n    Object.entries(facetableFields.object_fields).forEach(([field, info]) => {\n        if (info.facet_types.includes('terms')) {\n            config._facets[field] = { type: 'terms' };\n        } else if (info.facet_types.includes('range')) {\n            config._facets[field] = { \n                type: 'range',\n                ranges: generateRanges(info.sample_values)\n            };\n        }\n    });\n    \n    return config;\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"api-structure",children:"API Structure"}),"\n",(0,t.jsx)(n.h3,{id:"basic-query-structure",children:"Basic Query Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$query = [\n    // Search filters (same as searchObjects)\n    '@self' => [\n        'register' => 1,\n        'schema' => 2\n    ],\n    'status' => 'active',\n    '_search' => 'customer',\n    \n    // Facet configuration\n    '_facets' => [\n        // Metadata facets\n        '@self' => [\n            'register' => ['type' => 'terms'],\n            'schema' => ['type' => 'terms'],\n            'created' => [\n                'type' => 'date_histogram',\n                'interval' => 'month'\n            ]\n        ],\n        \n        // Object field facets\n        'status' => ['type' => 'terms'],\n        'priority' => ['type' => 'terms'],\n        'price' => [\n            'type' => 'range',\n            'ranges' => [\n                ['to' => 100],\n                ['from' => 100, 'to' => 500],\n                ['from' => 500]\n            ]\n        ]\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"response-structure",children:"Response Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"[\n    'facets' => [\n        '@self' => [\n            'register' => [\n                'type' => 'terms',\n                'buckets' => [\n                    ['key' => 1, 'doc_count' => 150, 'label' => 'Register Name'],\n                    ['key' => 2, 'doc_count' => 75, 'label' => 'Other Register']\n                ]\n            ],\n            'created' => [\n                'type' => 'date_histogram',\n                'interval' => 'month',\n                'buckets' => [\n                    ['key' => '2024-01', 'doc_count' => 45],\n                    ['key' => '2024-02', 'doc_count' => 67]\n                ]\n            ]\n        ],\n        'status' => [\n            'type' => 'terms',\n            'buckets' => [\n                ['key' => 'active', 'doc_count' => 134],\n                ['key' => 'inactive', 'doc_count' => 45]\n            ]\n        ],\n        'price' => [\n            'type' => 'range',\n            'buckets' => [\n                ['key' => '0-100', 'from' => 0, 'to' => 100, 'doc_count' => 120],\n                ['key' => '100-500', 'from' => 100, 'to' => 500, 'doc_count' => 80],\n                ['key' => '500+', 'from' => 500, 'doc_count' => 15]\n            ]\n        ]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"facet-types",children:"Facet Types"}),"\n",(0,t.jsx)(n.h3,{id:"1-terms-aggregation",children:"1. Terms Aggregation"}),"\n",(0,t.jsx)(n.p,{children:"For categorical data like status, priority, category, etc."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'_facets' => [\n    'status' => ['type' => 'terms'],\n    'priority' => ['type' => 'terms'],\n    '@self' => [\n        'register' => ['type' => 'terms'],\n        'schema' => ['type' => 'terms']\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Response:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'status' => [\n    'type' => 'terms',\n    'buckets' => [\n        ['key' => 'active', 'doc_count' => 134],\n        ['key' => 'pending', 'doc_count' => 45],\n        ['key' => 'inactive', 'doc_count' => 23]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-date-histogram",children:"2. Date Histogram"}),"\n",(0,t.jsx)(n.p,{children:"For time-based data with configurable intervals."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Supported intervals:"})," ",(0,t.jsx)(n.code,{children:"day"}),", ",(0,t.jsx)(n.code,{children:"week"}),", ",(0,t.jsx)(n.code,{children:"month"}),", ",(0,t.jsx)(n.code,{children:"year"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'_facets' => [\n    'event_date' => [\n        'type' => 'date_histogram',\n        'interval' => 'month'\n    ],\n    '@self' => [\n        'created' => [\n            'type' => 'date_histogram',\n            'interval' => 'week'\n        ]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Response:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'event_date' => [\n    'type' => 'date_histogram',\n    'interval' => 'month',\n    'buckets' => [\n        ['key' => '2024-01', 'doc_count' => 45],\n        ['key' => '2024-02', 'doc_count' => 67],\n        ['key' => '2024-03', 'doc_count' => 52]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-range-aggregation",children:"3. Range Aggregation"}),"\n",(0,t.jsx)(n.p,{children:"For numeric data with custom buckets."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'_facets' => [\n    'price' => [\n        'type' => 'range',\n        'ranges' => [\n            ['to' => 100],                    // 0-100\n            ['from' => 100, 'to' => 500],     // 100-500\n            ['from' => 500, 'to' => 1000],    // 500-1000\n            ['from' => 1000]                  // 1000+\n        ]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Response:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"'price' => [\n    'type' => 'range',\n    'buckets' => [\n        ['key' => '0-100', 'to' => 100, 'doc_count' => 120],\n        ['key' => '100-500', 'from' => 100, 'to' => 500, 'doc_count' => 80],\n        ['key' => '500-1000', 'from' => 500, 'to' => 1000, 'doc_count' => 35],\n        ['key' => '1000+', 'from' => 1000, 'doc_count' => 15]\n    ]\n]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"usage-examples",children:"Usage Examples"}),"\n",(0,t.jsx)(n.h3,{id:"basic-enumerated-facets",children:"Basic Enumerated Facets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$query = [\n    '@self' => ['register' => 1],\n    'status' => 'active',\n    '_facets' => [\n        '@self' => [\n            'register' => ['type' => 'terms'],\n            'schema' => ['type' => 'terms']\n        ],\n        'status' => ['type' => 'terms'],\n        'priority' => ['type' => 'terms']\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n\n// Use facet data for UI checkboxes\nforeach ($facets['facets']['status']['buckets'] as $bucket) {\n    $selected = ($bucket['key'] === 'active') ? 'checked' : '';\n    echo \"<input type='checkbox' {$selected}> {$bucket['key']} ({$bucket['doc_count']})\\n\";\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"date-timeline-facets",children:"Date Timeline Facets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$query = [\n    '_facets' => [\n        '@self' => [\n            'created' => [\n                'type' => 'date_histogram',\n                'interval' => 'month'\n            ]\n        ]\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n\n// Use for timeline visualization\nforeach ($facets['facets']['@self']['created']['buckets'] as $bucket) {\n    echo \"{$bucket['key']}: {$bucket['doc_count']} objects\\n\";\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"price-range-facets",children:"Price Range Facets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$query = [\n    '_facets' => [\n        'price' => [\n            'type' => 'range',\n            'ranges' => [\n                ['to' => 100],\n                ['from' => 100, 'to' => 500],\n                ['from' => 500]\n            ]\n        ]\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n\n// Use for price filter UI\nforeach ($facets['facets']['price']['buckets'] as $bucket) {\n    $from = $bucket['from'] ?? 0;\n    $to = $bucket['to'] ?? '\u221e';\n    echo \"\u20ac{$from} - \u20ac{$to}: {$bucket['doc_count']} items\\n\";\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-search",children:"Integration with Search"}),"\n",(0,t.jsx)(n.h3,{id:"combined-search-and-facets",children:"Combined Search and Facets"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$query = [\n    // Search filters\n    '@self' => [\n        'register' => [1, 2, 3],\n        'organisation' => 'IS NOT NULL'\n    ],\n    'status' => ['active', 'pending'],\n    '_search' => 'important customer',\n    '_published' => true,\n    \n    // Pagination\n    '_limit' => 25,\n    '_page' => 1,\n    \n    // Facet configuration\n    '_facets' => [\n        '@self' => [\n            'register' => ['type' => 'terms'],\n            'schema' => ['type' => 'terms']\n        ],\n        'status' => ['type' => 'terms'],\n        'priority' => ['type' => 'terms']\n    ]\n];\n\n// Get complete paginated results with facets\n$result = $objectService->searchObjectsPaginated($query);\n\n// Result contains:\n// - results: Array of objects\n// - total: Total count\n// - page/pages: Pagination info\n// - facets: Facet data\n"})}),"\n",(0,t.jsx)(n.h3,{id:"disjunctive-faceting-example",children:"Disjunctive Faceting Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// User has selected register=1 and status='active'\n$query = [\n    '@self' => ['register' => 1],\n    'status' => 'active',\n    '_facets' => [\n        '@self' => ['register' => ['type' => 'terms']],\n        'status' => ['type' => 'terms'],\n        'priority' => ['type' => 'terms']\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n\n// Register facet shows ALL registers (not just register 1)\n// Status facet shows ALL statuses (not just 'active')\n// Priority facet shows counts for register=1 AND status='active'\n\n// This allows users to change their register or status selection\n// without losing the ability to see other options\n"})}),"\n",(0,t.jsx)(n.h2,{id:"schema-based-facet-configuration",children:"Schema-Based Facet Configuration"}),"\n",(0,t.jsx)(n.p,{children:"The faceting system supports schema-driven facet discovery, allowing you to define which fields are facetable directly in your schema definitions."}),"\n",(0,t.jsx)(n.h3,{id:"schema-property-configuration",children:"Schema Property Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["Fields are marked as facetable in schema properties using the ",(0,t.jsx)(n.code,{children:"facetable"})," flag:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "properties": {\n    "status": {\n      "type": "string",\n      "title": "Status",\n      "description": "Current status of the item",\n      "facetable": true,\n      "example": "active"\n    },\n    "priority": {\n      "type": "integer",\n      "title": "Priority Level",\n      "description": "Priority from 1 to 10",\n      "facetable": true,\n      "minimum": 1,\n      "maximum": 10\n    },\n    "created_date": {\n      "type": "string",\n      "format": "date",\n      "title": "Creation Date",\n      "description": "When the item was created",\n      "facetable": true\n    },\n    "internal_notes": {\n      "type": "string",\n      "title": "Internal Notes",\n      "description": "Notes for internal use only",\n      "facetable": false\n    }\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"automatic-facet-type-detection",children:"Automatic Facet Type Detection"}),"\n",(0,t.jsx)(n.p,{children:"Based on schema property definitions, the system automatically determines appropriate facet types:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"String fields"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Regular strings \u2192 ",(0,t.jsx)(n.code,{children:"terms"})," facet"]}),"\n",(0,t.jsxs)(n.li,{children:["Date/datetime format \u2192 ",(0,t.jsx)(n.code,{children:"date_histogram"})," and ",(0,t.jsx)(n.code,{children:"range"})," facets"]}),"\n",(0,t.jsxs)(n.li,{children:["Email/URI/UUID format \u2192 ",(0,t.jsx)(n.code,{children:"terms"})," facet"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Numeric fields"})," (integer/number): ",(0,t.jsx)(n.code,{children:"range"})," and ",(0,t.jsx)(n.code,{children:"terms"})," facets"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Boolean fields"}),": ",(0,t.jsx)(n.code,{children:"terms"})," facet"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Array fields"}),": ",(0,t.jsx)(n.code,{children:"terms"})," facet"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"schema-based-discovery-benefits",children:"Schema-Based Discovery Benefits"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Performance Advantages:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No object data analysis required - discovery is instant"}),"\n",(0,t.jsx)(n.li,{children:"Consistent behavior - facets always available based on schema design"}),"\n",(0,t.jsx)(n.li,{children:"No sampling overhead - works regardless of data volume"}),"\n",(0,t.jsx)(n.li,{children:"Efficient - eliminates runtime field discovery queries"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Consistency:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Facets are always available based on schema, not data content"}),"\n",(0,t.jsx)(n.li,{children:"No need to worry about sample sizes for discovery"}),"\n",(0,t.jsx)(n.li,{children:"Predictable facet availability across all registers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"backend-implementation",children:"Backend Implementation"}),"\n",(0,t.jsx)(n.p,{children:"The system uses schema-based facet discovery through:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Schema Analysis"}),": Pre-computes facet configuration when schema is saved"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Facet Configuration Storage"}),": Stores facet metadata in schema entity"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Efficient Retrieval"}),": Fast lookup without object data analysis"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Core Components:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ObjectEntityMapper::getFacetableFieldsFromSchemas()"})," - Schema-based discovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Schema::regenerateFacetsFromProperties()"})," - Automatic facet configuration"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MariaDbFacetHandler"})," - Handles JSON object field facets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MetaDataFacetHandler"})," - Handles database table column facets"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsx)(n.h3,{id:"performance-impact",children:"Performance Impact"}),"\n",(0,t.jsx)(n.p,{children:"Real-world performance testing shows the following response time impacts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Regular API calls"})," - Baseline response time"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["With faceting (",(0,t.jsx)(n.code,{children:"_facets"}),")"]})," - Adds approximately ",(0,t.jsx)(n.strong,{children:"~10ms"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["With discovery (",(0,t.jsx)(n.code,{children:"_facetable=true"}),")"]})," - Adds approximately ",(0,t.jsx)(n.strong,{children:"~15ms"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combined faceting + discovery"})," - Adds approximately ",(0,t.jsx)(n.strong,{children:"~25ms"})," total"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"These measurements are based on typical datasets and may vary depending on:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Database size and object complexity"}),"\n",(0,t.jsx)(n.li,{children:"Number of facet fields being analyzed"}),"\n",(0,t.jsx)(n.li,{children:"Sample size used for discovery (default: 100 objects)"}),"\n",(0,t.jsx)(n.li,{children:"Server hardware and database configuration"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-operations",children:"Asynchronous Operations"}),"\n",(0,t.jsx)(n.p,{children:"For improved performance when using multiple operations (facets + facetable discovery), the system provides asynchronous methods that run database operations concurrently using ReactPHP."}),"\n",(0,t.jsx)(n.h4,{id:"performance-benefits",children:"Performance Benefits"}),"\n",(0,t.jsx)(n.p,{children:"Instead of sequential execution (~50ms total):"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Facetable discovery: ~15ms"}),"\n",(0,t.jsx)(n.li,{children:"Search results: ~10ms"}),"\n",(0,t.jsx)(n.li,{children:"Facets: ~10ms"}),"\n",(0,t.jsx)(n.li,{children:"Count: ~5ms"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Operations run concurrently, reducing total time to ~15ms (longest operation)."}),"\n",(0,t.jsx)(n.h4,{id:"available-methods",children:"Available Methods"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"searchObjectsPaginatedAsync(array $query): PromiseInterface"})})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Returns a ReactPHP promise that resolves to the same structure as ",(0,t.jsx)(n.code,{children:"searchObjectsPaginated()"})]}),"\n",(0,t.jsx)(n.li,{children:"Runs search, count, facets, and facetable discovery concurrently"}),"\n",(0,t.jsx)(n.li,{children:"Ideal for async/await patterns or promise chains"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"searchObjectsPaginatedSync(array $query): array"})})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Convenience method that executes the async version and waits for results"}),"\n",(0,t.jsx)(n.li,{children:"Provides performance benefits while maintaining synchronous interface"}),"\n",(0,t.jsxs)(n.li,{children:["Drop-in replacement for ",(0,t.jsx)(n.code,{children:"searchObjectsPaginated()"})," with better performance"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"usage-examples-1",children:"Usage Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Async with promise handling\n$promise = $objectService->searchObjectsPaginatedAsync($query);\n$promise->then(function ($results) {\n    // Handle results\n    return $results;\n});\n\n// Sync interface with async performance\n$results = $objectService->searchObjectsPaginatedSync($query);\n\n// Traditional sync method (slower for multiple operations)\n$results = $objectService->searchObjectsPaginated($query);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"when-to-use-async-methods",children:"When to Use Async Methods"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use async methods when"}),": Requesting both facets and facetable discovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use sync methods when"}),": Only requesting search results or single operation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance gain"}),": Most significant with ",(0,t.jsx)(n.code,{children:"_facets"})," + ",(0,t.jsx)(n.code,{children:"_facetable=true"})," combinations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"optimizations",children:"Optimizations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database-level aggregations"})," - Uses SQL GROUP BY for efficiency"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Indexed fields"})," - Metadata facets use indexed table columns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Disjunctive queries"})," - Optimized to exclude only the relevant filter"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Count optimization"})," - Uses COUNT(*) instead of selecting all data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Schema-based discovery"})," - No object data analysis required, instant discovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database indexes"})," - Critical indexes on ",(0,t.jsx)(n.code,{children:"deleted"}),", ",(0,t.jsx)(n.code,{children:"published"}),", ",(0,t.jsx)(n.code,{children:"created"}),", ",(0,t.jsx)(n.code,{children:"updated"}),", ",(0,t.jsx)(n.code,{children:"organisation"}),", ",(0,t.jsx)(n.code,{children:"owner"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Query batching"})," - Combines multiple facets where possible to reduce database round trips"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"database-index-optimization",children:"Database Index Optimization"}),"\n",(0,t.jsx)(n.p,{children:"For optimal facet performance, ensure these indexes exist:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Critical Indexes:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"deleted"})," - Used in every query for lifecycle filtering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"published"})," - Used for publication status filtering"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"created"}),", ",(0,t.jsx)(n.code,{children:"updated"})," - Common facet fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"organisation"}),", ",(0,t.jsx)(n.code,{children:"owner"})," - Common facet fields"]}),"\n",(0,t.jsx)(n.li,{children:"Composite indexes for filter combinations"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Performance Targets:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"With Indexes"}),": 0.5-1 second for complex facet queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Without Indexes"}),": 7+ seconds for same queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Register/Schema/Organisation facets"}),": 50-100ms each (with proper indexes)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JSON field facets"}),": Performance varies by dataset size"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Quick Performance Wins:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Apply database migrations to add critical indexes"}),"\n",(0,t.jsx)(n.li,{children:"Use schema-based discovery instead of object analysis"}),"\n",(0,t.jsx)(n.li,{children:"Limit facet scope to essential fields"}),"\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"_limit=0"})," for facet-only queries"]}),"\n",(0,t.jsxs)(n.li,{children:["Remove ",(0,t.jsx)(n.code,{children:"_facetable=true"})," if not needed (saves ~15ms)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use metadata facets when possible"})," - They perform better than JSON field facets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Limit range buckets"})," - Too many ranges can impact performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consider caching"})," - Facet results can be cached for frequently accessed data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Index JSON fields"})," - Consider adding indexes for frequently faceted JSON fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"_facetable"})," sparingly"]})," - Only request facetable discovery when building dynamic interfaces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Optimize sample size"})," - Balance accuracy vs performance for facetable discovery (default: 100 objects)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache facetable results"})," - Store discovery results for repeated interface building"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"migration-from-legacy-system",children:"Migration from Legacy System"}),"\n",(0,t.jsx)(n.h3,{id:"old-approach",children:"Old Approach"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Legacy faceting\n$config = [\n    'filters' => ['register' => 1, 'status' => 'active'],\n    '_queries' => ['status', 'priority', 'category']\n];\n\n$facets = $objectService->getFacets($config['filters'], $config['search']);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"new-approach",children:"New Approach"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// New comprehensive faceting\n$query = [\n    '@self' => ['register' => 1],\n    'status' => 'active',\n    '_facets' => [\n        '@self' => ['register' => ['type' => 'terms']],\n        'status' => ['type' => 'terms'],\n        'priority' => ['type' => 'terms'],\n        'category' => ['type' => 'terms']\n    ]\n];\n\n$facets = $objectService->getFacetsForObjects($query);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"backward-compatibility",children:"Backward Compatibility"}),"\n",(0,t.jsxs)(n.p,{children:["The system maintains backward compatibility. If no ",(0,t.jsx)(n.code,{children:"_facets"})," configuration is provided, it falls back to the legacy ",(0,t.jsx)(n.code,{children:"getFacets"})," method."]}),"\n",(0,t.jsx)(n.h2,{id:"ui-integration-examples",children:"UI Integration Examples"}),"\n",(0,t.jsx)(n.h3,{id:"dynamic-facet-discovery",children:"Dynamic Facet Discovery"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"// React component that discovers and builds facets dynamically\nconst DynamicFacetInterface = ({ baseQuery }) => {\n  const [facetableFields, setFacetableFields] = useState(null);\n  const [facetData, setFacetData] = useState(null);\n  const [filters, setFilters] = useState({});\n\n  useEffect(() => {\n    // Discover available facetable fields\n    const discoverFacets = async () => {\n      const response = await fetch('/api/objects?_facetable=true&limit=0', {\n        method: 'POST',\n        body: JSON.stringify(baseQuery)\n      });\n      const data = await response.json();\n      setFacetableFields(data.facetable);\n      \n      // Build initial facet configuration\n      const facetConfig = buildFacetConfig(data.facetable);\n      \n      // Get actual facet data\n      const facetResponse = await fetch('/api/objects', {\n        method: 'POST',\n        body: JSON.stringify(Object.assign({}, baseQuery, facetConfig))\n      });\n      const facetData = await facetResponse.json();\n      setFacetData(facetData.facets);\n    };\n\n    discoverFacets();\n  }, [baseQuery]);\n\n  const buildFacetConfig = (facetableFields) => {\n    const config = { _facets: { '@self': {} } };\n    \n    // Add metadata facets\n    Object.entries(facetableFields['@self'] || {}).forEach(([field, info]) => {\n      if (info.facet_types.includes('terms')) {\n        config._facets['@self'][field] = { type: 'terms' };\n      } else if (info.facet_types.includes('date_histogram')) {\n        config._facets['@self'][field] = { \n          type: 'date_histogram', \n          interval: 'month' \n        };\n      }\n    });\n    \n    // Add object field facets\n    Object.entries(facetableFields.object_fields || {}).forEach(([field, info]) => {\n      if (info.facet_types.includes('terms')) {\n        config._facets[field] = { type: 'terms' };\n      }\n    });\n    \n    return config;\n  };\n\n  if (!facetableFields || !facetData) {\n    return <div>Loading facets...</div>;\n  }\n\n  return (\n    <div className=\"dynamic-facets\">\n      <h2>Available Filters</h2>\n      \n      {/* Metadata facets */}\n      {Object.entries(facetData['@self'] || {}).map(([field, facet]) => (\n        <FacetFilter \n          key={'@self.' + field}\n          field={'@self.' + field}\n          facet={facet}\n          fieldInfo={facetableFields['@self'][field]}\n          onFilterChange={handleFilterChange}\n        />\n      ))}\n      \n      {/* Object field facets */}\n      {Object.entries(facetData).filter(([key]) => key !== '@self').map(([field, facet]) => (\n        <FacetFilter \n          key={field}\n          field={field}\n          facet={facet}\n          fieldInfo={facetableFields.object_fields[field]}\n          onFilterChange={handleFilterChange}\n        />\n      ))}\n    </div>\n  );\n};\n"})}),"\n",(0,t.jsx)(n.h3,{id:"enhanced-facet-component",children:"Enhanced Facet Component"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Enhanced facet component with discovery information\nconst FacetFilter = ({ field, facet, fieldInfo, onFilterChange }) => {\n  return (\n    <div className="facet-filter">\n      <h3>\n        {fieldInfo?.description || field}\n        <span className="facet-info">\n          ({fieldInfo?.type}, {fieldInfo?.appearance_rate} objects)\n        </span>\n      </h3>\n      \n      {facet.type === \'terms\' && (\n        <div className="checkbox-list">\n          {facet.buckets.map(bucket => (\n            <label key={bucket.key}>\n              <input \n                type="checkbox" \n                onChange={() => onFilterChange(field, bucket.key)}\n              />\n              {bucket.label || bucket.key} ({bucket.results})\n            </label>\n          ))}\n        </div>\n      )}\n      \n      {facet.type === \'range\' && (\n        <div className="range-list">\n          {facet.buckets.map(bucket => (\n            <button \n              key={bucket.key}\n              onClick={() => onFilterChange(field, bucket)}\n            >\n              {bucket.key}: {bucket.results} items\n            </button>\n          ))}\n        </div>\n      )}\n      \n      {facet.type === \'date_histogram\' && (\n        <div className="timeline">\n          <div className="interval-selector">\n            {fieldInfo?.intervals?.map(interval => (\n              <button \n                key={interval}\n                onClick={() => changeInterval(field, interval)}\n              >\n                {interval}\n              </button>\n            ))}\n          </div>\n          {facet.buckets.map(bucket => (\n            <div key={bucket.key} className="timeline-item">\n              <span>{bucket.key}</span>\n              <span>{bucket.results}</span>\n            </div>\n          ))}\n        </div>\n      )}\n      \n      {fieldInfo?.sample_values && (\n        <div className="sample-values">\n          <small>Sample values: {fieldInfo.sample_values.slice(0, 3).join(\', \')}</small>\n        </div>\n      )}\n    </div>\n  );\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"php-controller-example",children:"PHP Controller Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class SearchController extends Controller\n{\n    public function search(Request $request): JsonResponse\n    {\n        $query = [\n            // Extract filters from request\n            '@self' => [\n                'register' => $request->get('register'),\n                'schema' => $request->get('schema')\n            ],\n            'status' => $request->get('status'),\n            '_search' => $request->get('q'),\n            '_page' => $request->get('page', 1),\n            '_limit' => $request->get('limit', 20),\n            \n            // Facet configuration\n            '_facets' => [\n                '@self' => [\n                    'register' => ['type' => 'terms'],\n                    'schema' => ['type' => 'terms']\n                ],\n                'status' => ['type' => 'terms'],\n                'priority' => ['type' => 'terms'],\n                'category' => ['type' => 'terms']\n            ]\n        ];\n\n        $result = $this->objectService->searchObjectsPaginated($query);\n        \n        // Add facetable field discovery if requested\n        if ($request->get('_facetable') === 'true') {\n            $baseQuery = $query;\n            unset($baseQuery['_facets'], $baseQuery['_limit'], $baseQuery['_page']);\n            \n            $result['facetable'] = $this->objectService->getFacetableFields(\n                $baseQuery, \n                (int) $request->get('_sample_size', 100)\n            );\n        }\n        \n        return new JsonResponse($result);\n    }\n    \n    public function getFacetableFields(Request $request): JsonResponse\n    {\n        $baseQuery = [\n            '@self' => [\n                'register' => $request->get('register'),\n                'schema' => $request->get('schema')\n            ],\n            '_search' => $request->get('q')\n        ];\n        \n        $sampleSize = (int) $request->get('sample_size', 100);\n        \n        $facetableFields = $this->objectService->getFacetableFields($baseQuery, $sampleSize);\n        \n        return new JsonResponse([\n            'facetable' => $facetableFields,\n            'sample_size' => $sampleSize,\n            'base_query' => $baseQuery\n        ]);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,t.jsx)(n.h3,{id:"unit-test-examples",children:"Unit Test Examples"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"class FacetingTest extends TestCase\n{\n    public function testBasicTermsFacet(): void\n    {\n        $query = [\n            '_facets' => [\n                'status' => ['type' => 'terms']\n            ]\n        ];\n\n        $facets = $this->objectService->getFacetsForObjects($query);\n        \n        $this->assertArrayHasKey('facets', $facets);\n        $this->assertArrayHasKey('status', $facets['facets']);\n        $this->assertEquals('terms', $facets['facets']['status']['type']);\n        $this->assertIsArray($facets['facets']['status']['buckets']);\n    }\n\n    public function testDisjunctiveFaceting(): void\n    {\n        // Create test data with different statuses\n        $this->createTestObjects(['status' => 'active'], 10);\n        $this->createTestObjects(['status' => 'inactive'], 5);\n\n        $query = [\n            'status' => 'active',  // Filter by active\n            '_facets' => [\n                'status' => ['type' => 'terms']\n            ]\n        ];\n\n        $facets = $this->objectService->getFacetsForObjects($query);\n        \n        // Should show both active AND inactive in facets (disjunctive)\n        $statusBuckets = $facets['facets']['status']['buckets'];\n        $this->assertCount(2, $statusBuckets);\n        \n        $activeCount = $this->findBucketByKey($statusBuckets, 'active')['results'];\n        $inactiveCount = $this->findBucketByKey($statusBuckets, 'inactive')['results'];\n        \n        $this->assertEquals(10, $activeCount);\n        $this->assertEquals(5, $inactiveCount);\n    }\n\n    public function testFacetableFieldDiscovery(): void\n    {\n        // Create test objects with various field types\n        $this->createTestObjects([\n            'status' => 'active',\n            'priority' => 1,\n            'created_date' => '2024-01-15',\n            'is_featured' => true\n        ], 5);\n        \n        $this->createTestObjects([\n            'status' => 'inactive', \n            'priority' => 2,\n            'created_date' => '2024-02-20',\n            'is_featured' => false\n        ], 3);\n\n        $baseQuery = ['@self' => ['register' => 1]];\n        $facetableFields = $this->objectService->getFacetableFields($baseQuery, 50);\n        \n        // Check structure\n        $this->assertArrayHasKey('@self', $facetableFields);\n        $this->assertArrayHasKey('object_fields', $facetableFields);\n        \n        // Check metadata fields\n        $this->assertArrayHasKey('register', $facetableFields['@self']);\n        $this->assertEquals('categorical', $facetableFields['@self']['register']['type']);\n        $this->assertContains('terms', $facetableFields['@self']['register']['facet_types']);\n        \n        // Check object fields\n        $this->assertArrayHasKey('status', $facetableFields['object_fields']);\n        $this->assertEquals('string', $facetableFields['object_fields']['status']['type']);\n        $this->assertContains('terms', $facetableFields['object_fields']['status']['facet_types']);\n        \n        $this->assertArrayHasKey('priority', $facetableFields['object_fields']);\n        $this->assertEquals('integer', $facetableFields['object_fields']['priority']['type']);\n        $this->assertContains('range', $facetableFields['object_fields']['priority']['facet_types']);\n        \n        $this->assertArrayHasKey('is_featured', $facetableFields['object_fields']);\n        $this->assertEquals('boolean', $facetableFields['object_fields']['is_featured']['type']);\n        $this->assertContains('terms', $facetableFields['object_fields']['is_featured']['facet_types']);\n    }\n\n    public function testFacetableFieldFiltering(): void\n    {\n        // Create objects with high cardinality field (should be filtered out)\n        for ($i = 0; $i < 100; $i++) {\n            $this->createTestObjects([\n                'unique_id' => 'id_' . $i,  // High cardinality\n                'category' => 'cat_' . ($i % 3)  // Low cardinality\n            ], 1);\n        }\n\n        $facetableFields = $this->objectService->getFacetableFields([], 100);\n        \n        // High cardinality field should be filtered out\n        $this->assertArrayNotHasKey('unique_id', $facetableFields['object_fields']);\n        \n        // Low cardinality field should be included\n        $this->assertArrayHasKey('category', $facetableFields['object_fields']);\n        $this->assertEquals('low', $facetableFields['object_fields']['category']['cardinality']);\n    }\n\n    public function testFacetableFieldAppearanceThreshold(): void\n    {\n        // Create objects where some fields appear in less than 10% of objects\n        $this->createTestObjects(['common_field' => 'value1'], 50);  // 100% appearance\n        $this->createTestObjects(['rare_field' => 'value2'], 2);     // 4% appearance\n        \n        $facetableFields = $this->objectService->getFacetableFields([], 50);\n        \n        // Common field should be included\n        $this->assertArrayHasKey('common_field', $facetableFields['object_fields']);\n        \n        // Rare field should be filtered out (below 10% threshold)\n        $this->assertArrayNotHasKey('rare_field', $facetableFields['object_fields']);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"caching-and-label-resolution",children:"Caching and Label Resolution"}),"\n",(0,t.jsx)(n.h3,{id:"overview-1",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The faceting system includes an intelligent caching mechanism that resolves metadata field IDs (registers, schemas, organisations) and object UUIDs to human-readable names without sacrificing performance."}),"\n",(0,t.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,t.jsx)(n.h4,{id:"label-resolution-process",children:"Label Resolution Process"}),"\n",(0,t.jsx)(n.p,{children:"When facets are returned, the system automatically resolves IDs and UUIDs to human-readable names:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For metadata fields"})," ('_register', '_schema', '_organisation'):"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Collects IDs"})," from all facet buckets for batch processing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch loads entities"})," using optimized database queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Caches results"})," to prevent repeated database calls"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resolves labels"})," by mapping IDs to entity names/titles"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sorts alphabetically"})," by label for consistent ordering (case-insensitive A-Z)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For object fields"})," (any field containing UUIDs):"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detects UUIDs"})," by checking for hyphenated values"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch resolves"})," using ObjectCacheService.getMultipleObjectNames()"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Searches caches"})," (in-memory and distributed) before database"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extracts names"})," from common fields (naam, name, title, etc.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sorts alphabetically"})," by resolved names for user-friendly display"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"example-response",children:"Example Response"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Before label resolution:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "_register": {\n    "buckets": [\n      { "value": 5, "count": 114474, "label": 5 },\n      { "value": 6, "count": 8794, "label": 6 }\n    ]\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"After label resolution (alphabetically sorted):"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "_register": {\n    "buckets": [\n      { "value": 6, "count": 8794, "label": "Events Register" },\n      { "value": 5, "count": 114474, "label": "Publications Register" }\n    ]\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," Buckets are sorted alphabetically by label (A-Z), not by count or value."]}),"\n",(0,t.jsx)(n.h4,{id:"sorting-behavior",children:"Sorting Behavior"}),"\n",(0,t.jsx)(n.p,{children:"All term-based facets are automatically sorted alphabetically by label:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Metadata facets"})," (",(0,t.jsx)(n.code,{children:"_register"}),", ",(0,t.jsx)(n.code,{children:"_schema"}),", ",(0,t.jsx)(n.code,{children:"_organisation"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:'Sorted by resolved entity names (e.g., "Events Register", "Publications Register")'}),"\n",(0,t.jsx)(n.li,{children:"Case-insensitive alphabetical order (A, a, B, b, etc.)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Object field facets"})," (status, category, type, etc.):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Sorted by their resolved labels (UUIDs converted to object names)"}),"\n",(0,t.jsx)(n.li,{children:"Case-insensitive alphabetical order"}),"\n",(0,t.jsx)(n.li,{children:'Numeric strings sorted as text (e.g., "1", "10", "2")'}),"\n",(0,t.jsx)(n.li,{children:"UUIDs automatically resolved to human-readable object names using ObjectCacheService"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Date histogram facets"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Not sorted alphabetically (chronological order maintained)"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Range facets"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Not sorted alphabetically (range order maintained)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,t.jsx)(n.h4,{id:"static-caching-saveobjects",children:"Static Caching (SaveObjects)"}),"\n",(0,t.jsx)(n.p,{children:"Used during bulk save operations:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Schema Cache"})," - Stores loaded schemas to avoid repeated DB queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Register Cache"})," - Stores loaded registers to avoid repeated DB queries"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lifetime"})," - Lasts for the duration of the save operation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clearing"})," - Automatically cleared after bulk operation completes"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Example: Schema caching during bulk save\n$schema = $this->loadSchemaWithCache($schemaId);\n// Subsequent calls for same $schemaId return cached instance\n"})}),"\n",(0,t.jsx)(n.h4,{id:"entity-caching-objectservice",children:"Entity Caching (ObjectService)"}),"\n",(0,t.jsx)(n.p,{children:"Used during object retrieval and faceting:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"getCachedEntities()"})," - Generic caching method for schemas/registers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch Loading"})," - Fetches multiple entities in a single query"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fallback Mechanism"})," - Falls back to DB if cache unavailable"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Example: Batch loading registers for facets\n$registers = $this->getCachedEntities(\n    'register', \n    $registerIds, \n    [$this->registerMapper, 'findMultiple']\n);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"mapper-optimizations",children:"Mapper Optimizations"}),"\n",(0,t.jsx)(n.p,{children:"Specialized batch loading methods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"findMultipleOptimized()"})," - Single query for multiple IDs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Returns keyed array"})," - ID => Entity for fast lookups"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Used by facet processing"})," - Resolves labels efficiently"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Example: Optimized batch loading\n$schemas = $this->schemaMapper->findMultipleOptimized([1, 2, 3]);\n// Result: [1 => Schema1, 2 => Schema2, 3 => Schema3]\n"})}),"\n",(0,t.jsx)(n.h4,{id:"uuid-resolution-for-object-field-facets",children:"UUID Resolution for Object Field Facets"}),"\n",(0,t.jsx)(n.p,{children:"When object fields contain references to other objects via UUIDs, the system automatically resolves them to human-readable names:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"How it works:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detect UUIDs"})," - Identifies values that look like UUIDs (contain hyphens)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch lookup"})," - Uses ",(0,t.jsx)(n.code,{children:"ObjectCacheService.getMultipleObjectNames()"})," for efficient batch retrieval"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache first"})," - Checks in-memory and distributed caches before database"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multi-source"})," - Searches both organisations and objects tables"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Name extraction"})," - Uses common name fields (naam, name, title, contractNummer, achternaam)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fallback gracefully"})," - Uses UUID if name cannot be resolved"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example transformation:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'// Before UUID resolution:\n{\n  "customer": {\n    "buckets": [\n      { "value": "f47ac10b-58cc-4372-a567-0e02b2c3d479", "count": 42, "label": "f47ac10b-58cc-4372-a567-0e02b2c3d479" }\n    ]\n  }\n}\n\n// After UUID resolution (alphabetically sorted):\n{\n  "customer": {\n    "buckets": [\n      { "value": "f47ac10b-58cc-4372-a567-0e02b2c3d479", "count": 42, "label": "Acme Corporation" }\n    ]\n  }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Performance considerations:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cached UUIDs"})," - Already resolved names retrieved instantly from cache"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Batch loading"})," - New UUIDs loaded together in a single query"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Persistent cache"})," - Resolved names stored in distributed cache for all users"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Minimal overhead"})," - Only processes values that look like UUIDs (contain hyphens)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"performance-benefits-1",children:"Performance Benefits"}),"\n",(0,t.jsx)(n.h4,{id:"without-caching",children:"Without Caching"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"1 query per unique ID"})," in facet results"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"N+1 query problem"})," for large facet sets"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Response time"})," increases linearly with unique values"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"with-caching",children:"With Caching"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"1 query for all IDs"})," per facet field"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"No redundant queries"})," for same entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consistent performance"})," regardless of facet size"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"real-world-impact",children:"Real-World Impact"}),"\n",(0,t.jsx)(n.p,{children:"For a facet with 20 unique register IDs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Without caching"}),": 20 separate queries = ~500ms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"With caching"}),": 1 batch query = ~25ms"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance gain"}),": 20x faster"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsx)(n.h4,{id:"facet-processing-pipeline",children:"Facet Processing Pipeline"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SOLR returns raw facets"})," with numeric IDs"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"processFacetResponse()"})," detects metadata fields"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"formatMetadataFacetData()"})," called for register/schema/organisation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"resolveRegisterLabels()/resolveSchemaLabels()"})," batch load entities"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Labels mapped to buckets"})," before returning to frontend"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"code-flow-diagram",children:"Code Flow Diagram"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant API as API Request\n    participant GS as GuzzleSolrService\n    participant Cache as Entity Cache\n    participant Mapper as RegisterMapper\n    participant DB as Database\n\n    API->>GS: getFacets with _facets=extend\n    GS->>GS: Build facet query\n    GS->>GS: Execute SOLR query\n    GS->>GS: processFacetResponse()\n    \n    alt Metadata Field with Label Resolution\n        GS->>GS: formatMetadataFacetData()\n        GS->>GS: Extract IDs from buckets\n        GS->>GS: resolveRegisterLabels([5,6])\n        GS->>Cache: getCachedEntities('register', [5,6])\n        alt Cache Miss\n            Cache->>Mapper: findMultipleOptimized([5,6])\n            Mapper->>DB: SELECT * WHERE id IN (5,6)\n            DB--\x3e>Mapper: Register entities\n            Mapper--\x3e>Cache: [5=>Reg5, 6=>Reg6]\n            Cache->>Cache: Store in cache\n        end\n        Cache--\x3e>GS: [5=>Reg5, 6=>Reg6]\n        GS->>GS: Map labels to buckets\n    else Regular Field\n        GS->>GS: formatFacetData()\n    end\n    \n    GS--\x3e>API: Facets with resolved labels"}),"\n",(0,t.jsx)(n.h4,{id:"which-fields-get-label-resolution",children:"Which Fields Get Label Resolution"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Always Resolved:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"'_register' \u2192 Register title"}),"\n",(0,t.jsx)(n.li,{children:"'_schema' \u2192 Schema title or name"}),"\n",(0,t.jsx)(n.li,{children:"'_organisation' \u2192 Organisation name"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Never Resolved:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"'_created', '_updated' \u2192 Date fields use dates as labels"}),"\n",(0,t.jsx)(n.li,{children:"'_application' \u2192 String values remain as-is"}),"\n",(0,t.jsx)(n.li,{children:"Object fields \u2192 Use raw values as labels"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,t.jsx)(n.h4,{id:"facet-bucket-limits",children:"Facet Bucket Limits"}),"\n",(0,t.jsx)(n.p,{children:"The system limits the number of buckets (unique values) returned per facet to prevent performance issues:"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Default limit:"})," 1000 buckets per facet"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Metadata facets (",(0,t.jsx)(n.code,{children:"_register"}),", ",(0,t.jsx)(n.code,{children:"_schema"}),", ",(0,t.jsx)(n.code,{children:"_organisation"}),"): 1000 buckets"]}),"\n",(0,t.jsx)(n.li,{children:"Object field facets (status, category, type, etc.): 1000 buckets"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Why limit buckets?"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Prevents excessive memory usage"}),"\n",(0,t.jsx)(n.li,{children:"Keeps API responses manageable"}),"\n",(0,t.jsx)(n.li,{children:"Ensures consistent performance"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Need more buckets?"}),"\nYou can modify the limit in ",(0,t.jsx)(n.code,{children:"GuzzleSolrService.php"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Line 7851: Metadata fields"}),"\n",(0,t.jsx)(n.li,{children:"Line 7876: Object fields"}),"\n",(0,t.jsx)(n.li,{children:"Line 7906: Fallback facets"}),"\n",(0,t.jsxs)(n.li,{children:["Line 8231: buildTermsFacet() method (accepts ",(0,t.jsx)(n.code,{children:"$limit"})," parameter)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"For unlimited buckets"}),", set ",(0,t.jsx)(n.code,{children:"'limit' => -1"})," (use with caution!):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$facetConfig = [\n    'type' => 'terms',\n    'field' => 'self_register',\n    'limit' => -1, // Unlimited buckets\n    'mincount' => 1\n];\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," Very large facet sets may impact:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"API response time"}),"\n",(0,t.jsx)(n.li,{children:"Frontend rendering performance"}),"\n",(0,t.jsx)(n.li,{children:"Memory usage on both server and client"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"disabling-caching",children:"Disabling Caching"}),"\n",(0,t.jsx)(n.p,{children:"Caching is currently always enabled, but can be modified by changing the 'getCachedEntities()' method implementation:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"private function getCachedEntities(...): array\n{\n    // Current: Always use fallback (cache disabled)\n    return call_user_func($fallbackFunc, $ids);\n    \n    // To enable caching: Implement cache logic here\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"customizing-label-format",children:"Customizing Label Format"}),"\n",(0,t.jsx)(n.p,{children:"Modify the resolve methods to customize label formatting:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"private function resolveSchemaLabels(array $ids): array\n{\n    // Current: Uses title or name\n    $labels[$id] = $schema->getTitle() ?? $schema->getName() ?? \"Schema $id\";\n    \n    // Customize: Add more information\n    $labels[$id] = $schema->getTitle() . ' (' . $schema->getVersion() . ')';\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,t.jsx)(n.h4,{id:"labels-showing-as-ids",children:"Labels Showing as IDs"}),"\n",(0,t.jsx)(n.p,{children:"If facet labels are showing numeric IDs instead of names:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Verify the field is in the metadata fields list ('_register', '_schema', '_organisation')"}),"\n",(0,t.jsx)(n.li,{children:"Check database has entities with those IDs"}),"\n",(0,t.jsx)(n.li,{children:"Ensure entities have 'title'/'name' properties set"}),"\n",(0,t.jsx)(n.li,{children:"Review logs for label resolution errors"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,t.jsx)(n.p,{children:"If facet queries are slow:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Ensure batch loading methods are being used"}),"\n",(0,t.jsx)(n.li,{children:"Check database indexes on ID columns"}),"\n",(0,t.jsx)(n.li,{children:"Consider implementing actual caching in 'getCachedEntities()'"}),"\n",(0,t.jsx)(n.li,{children:"Monitor number of unique IDs per facet"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,t.jsx)(n.p,{children:"If stale labels appear after entity updates:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Static cache clears automatically after operations"}),"\n",(0,t.jsx)(n.li,{children:"For persistent cache (when implemented), clear on entity updates"}),"\n",(0,t.jsx)(n.li,{children:"Consider cache TTL for production deployments"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"The new faceting system provides a powerful, flexible, and user-friendly approach to building faceted search interfaces. It combines the best practices from modern search systems like Elasticsearch with the specific needs of the OpenRegister application."}),"\n",(0,t.jsx)(n.p,{children:"Key benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better UX"})," - Disjunctive faceting prevents options from disappearing"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"More flexible"})," - Supports multiple facet types and data sources"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Better performance"})," - Optimized database queries and intelligent caching"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Smart label resolution"})," - Automatic conversion of IDs to human-readable names"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modern API"})," - Familiar structure for developers"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Backward compatible"})," - Existing code continues to work"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic discovery"})," - Automatic detection of facetable fields helps build intelligent interfaces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Database-oriented"})," - All analysis happens at the database level for optimal performance"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"facetable-discovery-benefits",children:"Facetable Discovery Benefits"}),"\n",(0,t.jsx)(n.p,{children:"The facetable field discovery system provides several key advantages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dynamic Interface Building"})," - Frontends can automatically discover and build facet interfaces without hardcoding field lists"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data-Driven Configuration"})," - Facet types and options are determined by analyzing actual data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Context Awareness"})," - Discovery respects current filters to show relevant faceting options"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance Optimization"})," - Database-level analysis ensures efficient field discovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Type Intelligence"})," - Automatic detection of field types enables appropriate facet configurations"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"usage-recommendations",children:"Usage Recommendations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"_facetable=true"})]})," for initial interface discovery"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cache discovery results"})," for frequently accessed configurations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Combine with regular faceting"})," for complete search interfaces"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Leverage sample data"})," to show users what to expect"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Respect appearance rates"})," to focus on commonly used fields"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The system is designed to grow with your application's needs while maintaining excellent performance and user experience. The addition of facetable discovery makes it even easier to build intelligent, data-driven search interfaces that adapt to your content automatically."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"technical-architecture",children:"Technical Architecture"}),"\n",(0,t.jsx)(n.p,{children:"This section provides detailed visualization of the faceting system's architecture and data flow."}),"\n",(0,t.jsx)(n.h3,{id:"faceting-request-flow",children:"Faceting Request Flow"}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant API\n    participant ObjectService\n    participant FacetService\n    participant SolrService\n    participant Solr\n    participant Cache\n    \n    Client->>API: GET /api/objects?_facetable=true\n    API->>ObjectService: findObjects(_facetable=true)\n    \n    Note over ObjectService: Check if faceting requested\n    ObjectService->>FacetService: getFacetableFields(query)\n    \n    Note over FacetService: Analyze schema\n    FacetService->>FacetService: getSchemaFacets()\n    FacetService->>FacetService: discoverObjectFields()\n    \n    FacetService--\x3e>ObjectService: Facetable field definitions\n    \n    ObjectService->>SolrService: searchObjects(query + facets)\n    \n    Note over SolrService: Build facet query\n    SolrService->>SolrService: buildJsonFacetQuery()\n    SolrService->>SolrService: buildTermsFacet()\n    SolrService->>SolrService: buildDateHistogramFacet()\n    \n    SolrService->>Solr: POST /collection/select + json.facet\n    Solr--\x3e>SolrService: Facet results\n    \n    Note over SolrService: Process facet response\n    SolrService->>SolrService: processFacetResponse()\n    \n    Note over SolrService: UUID Resolution\n    SolrService->>SolrService: detectUUIDs()\n    SolrService->>Cache: getCachedObjects(uuids)\n    Cache--\x3e>SolrService: Cached names\n    SolrService->>SolrService: resolveRemainingUUIDs()\n    \n    Note over SolrService: Sort alphabetically\n    SolrService->>SolrService: sortFacetsAlphabetically()\n    \n    SolrService--\x3e>ObjectService: Enriched facet data\n    ObjectService--\x3e>API: Results + Facets\n    API--\x3e>Client: JSON Response"}),"\n",(0,t.jsx)(n.h3,{id:"facet-processing-pipeline-1",children:"Facet Processing Pipeline"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Faceting Request] --\x3e B{_facetable parameter?}\n    B --\x3e|true| C[Get Facetable Fields]\n    B --\x3e|false| D[Skip Faceting]\n    \n    C --\x3e E[Schema Analysis]\n    E --\x3e F[Get Pre-computed Facets]\n    E --\x3e G[Discover Object Fields]\n    \n    F --\x3e H[Merge Facet Definitions]\n    G --\x3e H\n    \n    H --\x3e I[Build Solr Facet Query]\n    I --\x3e J{Facet Type?}\n    J --\x3e|Terms| K[buildTermsFacet]\n    J --\x3e|Date Histogram| L[buildDateHistogramFacet]\n    J --\x3e|Range| M[buildRangeFacet]\n    \n    K --\x3e N[Execute Solr Query]\n    L --\x3e N\n    M --\x3e N\n    \n    N --\x3e O[Solr Returns Buckets]\n    O --\x3e P[Process Facet Response]\n    \n    P --\x3e Q{Contains UUIDs?}\n    Q --\x3e|Yes| R[UUID Resolution]\n    Q --\x3e|No| S[Format Buckets]\n    \n    R --\x3e T[Check Cache]\n    T --\x3e U{In Cache?}\n    U --\x3e|Yes| V[Use Cached Names]\n    U --\x3e|No| W[Batch Load from DB]\n    \n    W --\x3e X[Cache Results]\n    V --\x3e Y[Merge with Buckets]\n    X --\x3e Y\n    \n    Y --\x3e Z[Sort Alphabetically]\n    S --\x3e Z\n    \n    Z --\x3e AA[Return Enriched Facets]\n    \n    style I fill:#e1f5ff\n    style R fill:#ffe1e1\n    style T fill:#fff4e1"}),"\n",(0,t.jsx)(n.h3,{id:"uuid-resolution-process",children:"UUID Resolution Process"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\n    A[Facet Buckets] --\x3e B{Detect UUIDs}\n    B --\x3e|UUID Pattern Found| C[Extract UUID List]\n    B --\x3e|No UUIDs| D[Return Original]\n    \n    C --\x3e E[Lazy Load ObjectCacheService]\n    E --\x3e F{Service Available?}\n    F --\x3e|No| G[Use UUIDs as Labels]\n    F --\x3e|Yes| H[Batch Load Objects]\n    \n    H --\x3e I[Check Memory Cache]\n    I --\x3e J{In Memory?}\n    J --\x3e|Yes| K[Use Cached]\n    J --\x3e|No| L[Check Distributed Cache]\n    \n    L --\x3e M{In Cache?}\n    M --\x3e|Yes| N[Use Cached]\n    M --\x3e|No| O[Load from Database]\n    \n    O --\x3e P[Extract Name Fields]\n    P --\x3e Q[naam, name, title, etc.]\n    \n    K --\x3e R[Merge with Buckets]\n    N --\x3e R\n    Q --\x3e S[Cache Result]\n    S --\x3e R\n    \n    R --\x3e T[Sort by Label A-Z]\n    T --\x3e U[Return Enriched Facets]\n    \n    G --\x3e U\n    D --\x3e U\n    \n    style E fill:#e1f5ff\n    style I fill:#fff4e1\n    style L fill:#fff4e1\n    style O fill:#ffe1e1"}),"\n",(0,t.jsx)(n.h3,{id:"disjunctive-faceting-implementation",children:"Disjunctive Faceting Implementation"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[User Applies Filter] --\x3e B[Status=published]\n    B --\x3e C[Build Facet Queries]\n    \n    C --\x3e D{For Each Facet}\n    D --\x3e E[Status Facet]\n    D --\x3e F[Category Facet]\n    D --\x3e G[Priority Facet]\n    \n    Note over E: Exclude its own filter\n    E --\x3e H[Domain Filter without Status]\n    H --\x3e I[Apply: Category + Priority]\n    \n    Note over F: Exclude its own filter\n    F --\x3e J[Domain Filter without Category]\n    J --\x3e K[Apply: Status + Priority]\n    \n    Note over G: Exclude its own filter\n    G --\x3e L[Domain Filter without Priority]\n    L --\x3e M[Apply: Status + Category]\n    \n    I --\x3e N[Execute Solr Queries]\n    K --\x3e N\n    M --\x3e N\n    \n    N --\x3e O[Merge Results]\n    O --\x3e P[All Options Remain Visible]\n    \n    style C fill:#e1f5ff\n    style O fill:#e1ffe1"}),"\n",(0,t.jsx)(n.h3,{id:"facet-type-selection-logic",children:"Facet Type Selection Logic"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Analyze Field] --\x3e B{Field Type?}\n    B --\x3e|String| C{Cardinality?}\n    B --\x3e|Numeric| D[Terms + Range]\n    B --\x3e|Date| E[Date Histogram + Range]\n    B --\x3e|Boolean| F[Terms Only]\n    \n    C --\x3e|Low \u226450| G[Terms Facet]\n    C --\x3e|High >50| H[Not Suitable]\n    \n    G --\x3e I[categorical]\n    D --\x3e J[numeric]\n    E --\x3e K[date]\n    F --\x3e L[binary]\n    H --\x3e M[Skip Faceting]\n    \n    I --\x3e N[Return Facet Config]\n    J --\x3e N\n    K --\x3e N\n    L --\x3e N\n    M --\x3e O[Exclude from Facets]\n    \n    style B fill:#e1f5ff\n    style N fill:#e1ffe1"}),"\n",(0,t.jsx)(n.h3,{id:"caching-strategy-1",children:"Caching Strategy"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[UUID Resolution Request] --\x3e B[Check Memory Cache]\n    B --\x3e C{Exists?}\n    C --\x3e|Yes| D[Return <10ms]\n    C --\x3e|No| E[Check Distributed Cache]\n    \n    E --\x3e F{Exists?}\n    F --\x3e|Yes| G[Return <50ms]\n    F --\x3e|No| H[Database Query]\n    \n    H --\x3e I[Batch Load Objects]\n    I --\x3e J[Extract Names]\n    \n    J --\x3e K[Store in Distributed Cache]\n    K --\x3e L[Store in Memory Cache]\n    \n    L --\x3e M[Return <100ms for 100 UUIDs]\n    \n    D --\x3e N[Facet Response]\n    G --\x3e N\n    M --\x3e N\n    \n    style B fill:#fff4e1\n    style E fill:#fff4e1\n    style H fill:#ffe1e1\n    style N fill:#e1ffe1"}),"\n",(0,t.jsx)(n.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Facet Query Performance:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Without Faceting:    ~50ms  (search only)\nWith Faceting:       ~80ms  (search + 5 facets)\nWith UUID Resolution: ~120ms (search + 5 facets + 100 UUID resolutions)\nWith Full Caching:   ~60ms  (search + 5 facets + cached UUIDs)\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Caching Impact:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Memory Cache Hit:     <10ms   per UUID resolution\nDistributed Cache:    <50ms   per batch (100 UUIDs)\nDatabase Query:       <100ms  per batch (100 UUIDs)\nNo Cache:             ~1000ms for 100 individual queries\n"})}),"\n",(0,t.jsx)(n.h3,{id:"code-examples",children:"Code Examples"}),"\n",(0,t.jsx)(n.h4,{id:"building-custom-facet-query",children:"Building Custom Facet Query"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"use OCA\\OpenRegister\\Service\\FacetService;\n\n// Get facetable fields\n$facetableFields = $facetService->getFacetableFields([\n    '@self' => ['register' => 5],\n    '_search' => 'budget'\n], 100);\n\n// Build facet configuration\n$facets = [\n    'status' => [\n        'type' => 'terms',\n        'field' => 'status_s',\n        'limit' => 50\n    ],\n    'created' => [\n        'type' => 'date_histogram',\n        'field' => 'self_created',\n        'interval' => 'month'\n    ]\n];\n\n// Execute search with facets\n$results = $objectService->findObjects([\n    '_source' => 'index',\n    '_facetable' => true,\n    '_facets' => $facets\n]);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"processing-facet-results",children:"Processing Facet Results"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"// Access facet data\n$facets = $results['facets'];\n\nforeach ($facets['@self'] as $fieldName => $facetData) {\n    echo \"Facet: \" . $facetData['description'] . \"\\n\";\n    \n    foreach ($facetData['data'] as $bucket) {\n        echo \"  - \" . $bucket['label'] . \": \" . $bucket['count'] . \"\\n\";\n    }\n}\n\n// Process object field facets\nforeach ($facets['object_fields'] as $fieldName => $facetData) {\n    echo \"Object Field: \" . $fieldName . \"\\n\";\n    \n    foreach ($facetData['data'] as $bucket) {\n        echo \"  - \" . $bucket['value'] . \": \" . $bucket['count'] . \"\\n\";\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"testing-1",children:"Testing"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Run faceting tests\nvendor/bin/phpunit tests/Service/FacetServiceTest.php\n\n# Test specific scenarios\nvendor/bin/phpunit --filter testDisjunctiveFaceting\nvendor/bin/phpunit --filter testUUIDResolution\nvendor/bin/phpunit --filter testFacetDiscovery\n\n# Integration tests\nvendor/bin/phpunit tests/Integration/FacetIntegrationTest.php\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Test Coverage:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Facet type detection"}),"\n",(0,t.jsx)(n.li,{children:"UUID resolution and caching"}),"\n",(0,t.jsx)(n.li,{children:"Disjunctive faceting behavior"}),"\n",(0,t.jsx)(n.li,{children:"Alphabetical sorting"}),"\n",(0,t.jsx)(n.li,{children:"Date histogram buckets"}),"\n",(0,t.jsx)(n.li,{children:"Range aggregations"}),"\n",(0,t.jsx)(n.li,{children:"Performance benchmarks"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}}}]);