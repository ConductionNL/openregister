(self.webpackChunkopen_catalogi_docs=self.webpackChunkopen_catalogi_docs||[]).push([[7767],{7411:()=>{},28453:(e,n,t)=>{"use strict";t.d(n,{R:()=>i,x:()=>a});var r=t(96540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}},28825:()=>{},45673:(e,n,t)=>{"use strict";t.d(n,{A:()=>h});var r=t(96540),s=t(20053),o=t(44404),i=(t(34345),t(28794)),a=t(54022),c=t(72077);function l(e){const n=(0,c.kh)("docusaurus-plugin-redoc");return e?n?.[e]:Object.values(n??{})?.[0]}var u=t(74848);const d=e=>{let{id:n,example:t,pointer:c,...d}=e;const h=l(n),{store:p}=(0,a.r)(h);return(0,r.useEffect)((()=>{p.menu.dispose()}),[p]),(0,u.jsx)(o.ThemeProvider,{theme:p.options.theme,children:(0,u.jsx)("div",{className:(0,s.A)(["redocusaurus","redocusaurus-schema",t?null:"hide-example"]),children:(0,u.jsx)(i.SchemaDefinition,{parser:p.spec.parser,options:p.options,schemaRef:c,...d})})})};d.defaultProps={example:!1};const h=d},65537:(e,n,t)=>{"use strict";t.d(n,{A:()=>w});var r=t(96540),s=t(18215),o=t(65627),i=t(56347),a=t(50372),c=t(30604),l=t(11861),u=t(78749);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=n??function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,l.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const s=(0,i.W6)(),o=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:n,groupId:t});return[(0,c.aZ)(o),(0,r.useCallback)((e=>{if(!o)return;const n=new URLSearchParams(s.location.search);n.set(o,e),s.replace({...s.location,search:n.toString()})}),[o,s])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,o=h(e),[i,c]=(0,r.useState)((()=>function(e){let{defaultValue:n,tabValues:t}=e;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!p({value:n,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const r=t.find((e=>e.default))??t[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:o}))),[l,d]=g({queryString:t,groupId:s}),[f,m]=function(e){let{groupId:n}=e;const t=function(e){return e?`docusaurus.tab.${e}`:null}(n),[s,o]=(0,u.Dv)(t);return[s,(0,r.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:s}),v=(()=>{const e=l??f;return p({value:e,tabValues:o})?e:null})();(0,a.A)((()=>{v&&c(v)}),[v]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),d(e),m(e)}),[d,m,o]),tabValues:o}}var m=t(9136);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=t(74848);function b(e){let{className:n,block:t,selectedValue:r,selectValue:i,tabValues:a}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),u=e=>{const n=e.currentTarget,t=c.indexOf(n),s=a[t].value;s!==r&&(l(n),i(s))},d=e=>{let n=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const t=c.indexOf(e.currentTarget)+1;n=c[t]??c[0];break}case"ArrowLeft":{const t=c.indexOf(e.currentTarget)-1;n=c[t]??c[c.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":t},n),children:a.map((e=>{let{value:n,label:t,attributes:o}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>{c.push(e)},onKeyDown:d,onClick:u,...o,className:(0,s.A)("tabs__item",v.tabItem,o?.className,{"tabs__item--active":r===n}),children:t??n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:o}=e;const i=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===o));return e?(0,r.cloneElement)(e,{className:(0,s.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function y(e){const n=f(e);return(0,x.jsxs)("div",{className:(0,s.A)("tabs-container",v.tabList),children:[(0,x.jsx)(b,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function w(e){const n=(0,m.A)();return(0,x.jsx)(y,{...e,children:d(e.children)},String(n))}},67992:()=>{},79329:(e,n,t)=>{"use strict";t.d(n,{A:()=>i});t(96540);var r=t(18215);const s={tabItem:"tabItem_Ymn6"};var o=t(74848);function i(e){let{children:n,hidden:t,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,i),hidden:t,children:n})}},83350:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"Features/sources","title":"Sources","description":"An overview of how core concepts in Open Register interact with each other.","source":"@site/docs/Features/sources.md","sourceDirName":"Features","slug":"/Features/sources","permalink":"/docs/Features/sources","draft":false,"unlisted":false,"editUrl":"https://github.com/conductionnl/openregister/tree/main/website/docs/Features/sources.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Sources","sidebar_position":4,"description":"An overview of how core concepts in Open Register interact with each other.","keywords":["Open Register","Core Concepts","Relationships"]},"sidebar":"tutorialSidebar","previous":{"title":"Text Extraction, Vectorization & Named Entity Recognition","permalink":"/docs/Features/text-extraction-vectorization-ner"},"next":{"title":"AI Chat Interface","permalink":"/docs/Features/ai"}}');var s=t(74848),o=t(28453),i=t(45673);t(65537),t(79329);const a={title:"Sources",sidebar_position:4,description:"An overview of how core concepts in Open Register interact with each other.",keywords:["Open Register","Core Concepts","Relationships"]},c="Sources",l={},u=[{value:"What is a Source?",id:"what-is-a-source",level:2},{value:"Source Structure",id:"source-structure",level:2},{value:"Supported Source Types",id:"supported-source-types",level:2},{value:"1. Internal",id:"1-internal",level:3},{value:"2. MongoDB",id:"2-mongodb",level:3},{value:"3. Custom Sources (via Extensions)",id:"3-custom-sources-via-extensions",level:3},{value:"Source Use Cases",id:"source-use-cases",level:2},{value:"1. Storage Configuration",id:"1-storage-configuration",level:3},{value:"2. Performance Optimization",id:"2-performance-optimization",level:3},{value:"3. Data Segregation",id:"3-data-segregation",level:3},{value:"4. Scalability",id:"4-scalability",level:3},{value:"Working with Sources",id:"working-with-sources",level:2},{value:"Creating a Source",id:"creating-a-source",level:3},{value:"Retrieving Source Information",id:"retrieving-source-information",level:3},{value:"Updating a Source",id:"updating-a-source",level:3},{value:"Deleting a Source",id:"deleting-a-source",level:3},{value:"Source Configuration Best Practices",id:"source-configuration-best-practices",level:2},{value:"Relationship to Other Concepts",id:"relationship-to-other-concepts",level:2},{value:"Advanced Source Features",id:"advanced-source-features",level:2},{value:"Connection Pooling",id:"connection-pooling",level:3},{value:"Read/Write Separation",id:"readwrite-separation",level:3},{value:"Sharding and Partitioning",id:"sharding-and-partitioning",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"sources",children:"Sources"})}),"\n",(0,s.jsx)(n.h2,{id:"what-is-a-source",children:"What is a Source?"}),"\n",(0,s.jsxs)(n.p,{children:["In Open Register, a ",(0,s.jsx)(n.strong,{children:"Source"})," defines where and how data is stored. Sources provide the connection details and configuration for the storage backends that hold your registers and objects. They act as the bridge between your data model and the physical storage layer."]}),"\n",(0,s.jsx)(n.p,{children:"Sources allow Open Register to support multiple storage technologies, giving you flexibility in how you deploy and scale your data management solution."}),"\n",(0,s.jsx)(n.h2,{id:"source-structure",children:"Source Structure"}),"\n",(0,s.jsx)(n.p,{children:"A source in Open Register consists of the following key components:"}),"\n",(0,s.jsx)(i.A,{id:"open-register",example:!0,pointer:"#/components/schemas/Source"}),"\n",(0,s.jsx)(n.h2,{id:"supported-source-types",children:"Supported Source Types"}),"\n",(0,s.jsx)(n.p,{children:"Open Register supports multiple types of storage backends:"}),"\n",(0,s.jsx)(n.h3,{id:"1-internal",children:"1. Internal"}),"\n",(0,s.jsx)(n.p,{children:"The internal source type uses Nextcloud's built-in database for storage. This is the simplest option and works well for smaller deployments or when you want to keep everything within Nextcloud."}),"\n",(0,s.jsx)(n.h3,{id:"2-mongodb",children:"2. MongoDB"}),"\n",(0,s.jsx)(n.p,{children:"MongoDB sources provide scalable, document-oriented storage that works well with JSON data. This option is good for larger deployments or when you need advanced querying capabilities."}),"\n",(0,s.jsx)(n.h3,{id:"3-custom-sources-via-extensions",children:"3. Custom Sources (via Extensions)"}),"\n",(0,s.jsx)(n.p,{children:"The Open Register architecture allows for extending the system with custom source types through extensions, enabling integration with other database technologies or specialized storage systems."}),"\n",(0,s.jsx)(n.h2,{id:"source-use-cases",children:"Source Use Cases"}),"\n",(0,s.jsx)(n.p,{children:"Sources serve several important purposes in Open Register:"}),"\n",(0,s.jsx)(n.h3,{id:"1-storage-configuration",children:"1. Storage Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Sources define where your data is physically stored, allowing you to choose the right database technology for your needs."}),"\n",(0,s.jsx)(n.h3,{id:"2-performance-optimization",children:"2. Performance Optimization"}),"\n",(0,s.jsx)(n.p,{children:"Different sources can be configured for different performance characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High-throughput sources for frequently accessed data"}),"\n",(0,s.jsx)(n.li,{children:"Archival sources for historical data"}),"\n",(0,s.jsx)(n.li,{children:"In-memory sources for ultra-fast access to critical data"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-data-segregation",children:"3. Data Segregation"}),"\n",(0,s.jsx)(n.p,{children:"Multiple sources allow you to segregate data based on security requirements, regulatory needs, or organizational boundaries."}),"\n",(0,s.jsx)(n.h3,{id:"4-scalability",children:"4. Scalability"}),"\n",(0,s.jsx)(n.p,{children:"As your data grows, you can add new sources to distribute the load across multiple databases or clusters."}),"\n",(0,s.jsx)(n.h2,{id:"working-with-sources",children:"Working with Sources"}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-source",children:"Creating a Source"}),"\n",(0,s.jsx)(n.p,{children:"To create a new source, you define its connection details and type:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'POST /api/sources\n{\n  "title": "Analytics Database",\n  "description": "Database for analytics data",\n  "databaseUrl": "mongodb://analytics.example.com:27017/analytics",\n  "type": "mongodb"\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-source-information",children:"Retrieving Source Information"}),"\n",(0,s.jsx)(n.p,{children:"You can retrieve information about a specific source:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"GET /api/sources/{id}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Or list all available sources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"GET /api/sources\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updating-a-source",children:"Updating a Source"}),"\n",(0,s.jsx)(n.p,{children:"Sources can be updated to change connection details or other properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'PUT /api/sources/{id}\n{\n  "title": "Analytics Database",\n  "description": "Updated database for analytics data",\n  "databaseUrl": "mongodb://new-analytics.example.com:27017/analytics",\n  "type": "mongodb"\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"deleting-a-source",children:"Deleting a Source"}),"\n",(0,s.jsx)(n.p,{children:"Sources can be deleted when no longer needed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"DELETE /api/sources/{id}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Deleting a source does not delete the data in the underlying database. It only removes the connection configuration from Open Register."]}),"\n",(0,s.jsx)(n.h2,{id:"source-configuration-best-practices",children:"Source Configuration Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Descriptive Names"}),": Give sources clear, descriptive names that indicate their purpose"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Connection Details"}),": Keep detailed documentation of connection strings and credentials"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitor Performance"}),": Regularly monitor source performance and adjust as needed"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan for Growth"}),": Design your source strategy with future growth in mind"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Security First"}),": Use secure connection strings and follow database security best practices"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Regular Backups"}),": Ensure all sources have appropriate backup strategies"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"relationship-to-other-concepts",children:"Relationship to Other Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Registers"}),": Registers are associated with sources that determine where their data is stored"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Objects"}),": Objects are stored in the sources configured for their registers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Databases"}),": Sources provide the connection details for the physical databases"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-source-features",children:"Advanced Source Features"}),"\n",(0,s.jsx)(n.h3,{id:"connection-pooling",children:"Connection Pooling"}),"\n",(0,s.jsx)(n.p,{children:"For high-traffic deployments, sources can be configured with connection pooling to optimize database connections."}),"\n",(0,s.jsx)(n.h3,{id:"readwrite-separation",children:"Read/Write Separation"}),"\n",(0,s.jsx)(n.p,{children:"Some source types support configuring separate read and write endpoints, allowing you to optimize for different access patterns."}),"\n",(0,s.jsx)(n.h3,{id:"sharding-and-partitioning",children:"Sharding and Partitioning"}),"\n",(0,s.jsx)(n.p,{children:"For very large datasets, sources can be configured to support sharding or partitioning strategies."}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Sources are a critical part of the Open Register architecture, providing the flexibility to choose the right storage technology for your needs while maintaining a consistent data model and API. By separating the storage configuration from the data model, Open Register allows you to evolve your storage strategy independently from your data structure, giving you the best of both worlds: structured data with flexible storage options."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},92441:()=>{},93290:()=>{}}]);