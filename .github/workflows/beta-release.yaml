name: Beta Release

on:
  push:
    branches:
      - beta
      # - code-refactor/ObjectService

jobs:
  release-management:
    runs-on: ubuntu-latest
    steps:

      # Stap 1: Code ophalen
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          ssh-key: ${{ secrets.DEPLOY_KEY }}

      # Stap 2: Stel de appnaam in (gebruik de repo-naam)
      - name: Set app env
        run: |
          echo "APP_NAME=${GITHUB_REPOSITORY##*/}" >> $GITHUB_ENV

      # Stap 3: Haal huidige versie uit info.xml, verhoog de patch en voeg beta-suffix toe
      - name: Get current version and append beta suffix
        id: increment_version
        run: |
          # Get version from main branch
          git fetch origin main
          main_version=$(git show origin/main:appinfo/info.xml | grep -oP '(?<=<version>)[^<]+' || echo "")

          # Get current version from feature/php-linting branch
          current_version=$(grep -oP '(?<=<version>)[^<]+' appinfo/info.xml || echo "")

          # Split main version into parts
          IFS='.' read -ra main_version_parts <<< "$main_version"

          # Increment patch version by 1 from main
          next_patch=$((main_version_parts[2] + 1))

          # Extract beta counter from current version if it exists
          beta_counter=1
          if [[ $current_version =~ -beta\.([0-9]+)$ ]]; then
            # If current patch version is still ahead of main, increment counter
            current_patch=$(echo $current_version | grep -oP '^[0-9]+\.[0-9]+\.(\d+)' | cut -d. -f3)
            if [ "$current_patch" -eq "$next_patch" ]; then
              beta_counter=$((BASH_REMATCH[1] + 1))
            fi
          fi

          beta_version="${main_version_parts[0]}.${main_version_parts[1]}.${next_patch}-beta.${beta_counter}"

          echo "NEW_VERSION=$beta_version" >> $GITHUB_ENV
          echo "new_version=$beta_version" >> $GITHUB_OUTPUT
          echo "Main version: $main_version"
          echo "Current version: $current_version"
          echo "Using beta version: $beta_version"

      # Stap 4: Genereer changelog entries vanaf laatste release met PR descriptions
      - name: Generate changelog entries from PRs
        id: generate_changelog
        run: |
          # Get the date for the changelog entry
          RELEASE_DATE=$(date +%Y-%m-%d)

          # Find the last release tag (beta or main)
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          # Determine the base commit for finding PRs
          if [ -z "$LAST_TAG" ]; then
            # If no tag exists, use main branch as base
            git fetch origin main
            BASE_SHA=$(git rev-parse origin/main)
            echo "No previous tag found, using main branch as base: $BASE_SHA"
          else
            # Use the tag as base
            BASE_SHA=$(git rev-parse "$LAST_TAG")
            echo "Found last tag: $LAST_TAG ($BASE_SHA)"
          fi

          CURRENT_SHA=$(git rev-parse HEAD)

          # Create category files before processing
          FEATURES_FILE=$(mktemp)
          FIXES_FILE=$(mktemp)
          DOCS_FILE=$(mktemp)
          IMPROVEMENTS_FILE=$(mktemp)
          OTHER_FILE=$(mktemp)

          # Track PRs we've already processed (by PR number)
          PROCESSED_PRS=$(mktemp)

          # Fetch PRs that were merged into the beta branch
          # We'll query PRs and check if their merge commit is in our range
          echo "Fetching merged PRs from GitHub API..."

          # Get all commits in the range
          COMMITS_IN_RANGE=$(git log --pretty=format:"%H" "$BASE_SHA..$CURRENT_SHA")

          # For each commit, check if it's a merge commit and find associated PR
          for commit_sha in $COMMITS_IN_RANGE; do
            # Skip if this commit is a version bump or skip-changelog
            commit_msg=$(git log -1 --pretty=format:"%s" "$commit_sha")
            if echo "$commit_msg" | grep -qiE "\[skip ci\]|Bump.*version|skip-changelog"; then
              continue
            fi

            # Try to find PR associated with this commit
            # GitHub API: GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls
            pr_data=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/commits/$commit_sha/pulls" || echo "[]")

            # Parse PR numbers from response
            pr_numbers=$(echo "$pr_data" | jq -r '.[].number' 2>/dev/null || echo "")

            if [ -n "$pr_numbers" ]; then
              for pr_num in $pr_numbers; do
                # Skip if we've already processed this PR
                if grep -q "^$pr_num$" "$PROCESSED_PRS"; then
                  continue
                fi

                # Mark as processed
                echo "$pr_num" >> "$PROCESSED_PRS"

                # Fetch PR details
                pr_info=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github+json" \
                  "https://api.github.com/repos/${{ github.repository }}/pulls/$pr_num" || echo "{}")

                # Check if PR is merged and not excluded
                pr_state=$(echo "$pr_info" | jq -r '.state // "unknown"' 2>/dev/null)
                pr_merged=$(echo "$pr_info" | jq -r '.merged // false' 2>/dev/null)
                pr_labels=$(echo "$pr_info" | jq -r '[.labels[].name] | join(",")' 2>/dev/null || echo "")

                # Skip if PR is not merged or has skip-changelog label
                if [ "$pr_state" != "closed" ] || [ "$pr_merged" != "true" ]; then
                  continue
                fi

                if echo "$pr_labels" | grep -qi "skip-changelog"; then
                  echo "Skipping PR #$pr_num (has skip-changelog label)"
                  continue
                fi

                # Extract PR information
                pr_title=$(echo "$pr_info" | jq -r '.title // ""' 2>/dev/null)
                pr_body=$(echo "$pr_info" | jq -r '.body // ""' 2>/dev/null)
                pr_url=$(echo "$pr_info" | jq -r '.html_url // ""' 2>/dev/null)

                # Use PR description (body) if available, otherwise use title
                if [ -n "$pr_body" ] && [ "$pr_body" != "null" ] && [ "$pr_body" != "" ]; then
                  # Clean up PR body - remove markdown code blocks, images, and formatting
                  # Extract first meaningful paragraph (skip empty lines and common prefixes)
                  pr_description=$(echo "$pr_body" | \
                    sed -E 's/```[^`]*```//g' | \
                    sed -E 's/!\[.*\]\(.*\)//g' | \
                    sed -E 's/#+ //g' | \
                    sed -E 's/^\*\*.*\*\*$//g' | \
                    grep -v '^[[:space:]]*$' | \
                    head -n 5 | \
                    tr '\n' ' ' | \
                    sed -E 's/^[[:space:]]+|[[:space:]]+$//g' | \
                    sed -E 's/[[:space:]]+/ /g')

                  # If description is too long, too short, or empty, use title
                  if [ ${#pr_description} -gt 250 ] || [ ${#pr_description} -lt 10 ] || [ -z "$pr_description" ]; then
                    pr_description="$pr_title"
                  fi
                else
                  pr_description="$pr_title"
                fi

                # Create entry with PR link
                entry="- ${pr_description} ([#${pr_num}](${pr_url}))"

                # Categorize based on PR labels first (more accurate), then fall back to title/content
                category="OTHER"
                if echo "$pr_labels" | grep -qiE "(feature|feat|enhancement)"; then
                  category="FEATURES"
                elif echo "$pr_labels" | grep -qiE "(bug|bugfix|fix|hotfix)"; then
                  category="FIXES"
                elif echo "$pr_labels" | grep -qiE "(doc|docs|documentation)"; then
                  category="DOCS"
                elif echo "$pr_labels" | grep -qiE "(refactor|perf|style|chore|improvements)"; then
                  category="IMPROVEMENTS"
                elif echo "$pr_title" | grep -qiE "^(feat|feature|add|new):"; then
                  category="FEATURES"
                elif echo "$pr_title" | grep -qiE "^(fix|bugfix|bug|hotfix):"; then
                  category="FIXES"
                elif echo "$pr_title" | grep -qiE "^(doc|docs|documentation):"; then
                  category="DOCS"
                elif echo "$pr_title" | grep -qiE "^(refactor|perf|style|chore|improve|improvement):"; then
                  category="IMPROVEMENTS"
                fi

                # Write to appropriate category file
                case "$category" in
                  FEATURES)
                    echo "$entry" >> "$FEATURES_FILE"
                    ;;
                  FIXES)
                    echo "$entry" >> "$FIXES_FILE"
                    ;;
                  DOCS)
                    echo "$entry" >> "$DOCS_FILE"
                    ;;
                  IMPROVEMENTS)
                    echo "$entry" >> "$IMPROVEMENTS_FILE"
                    ;;
                  *)
                    echo "$entry" >> "$OTHER_FILE"
                    ;;
                esac
              done
            fi
          done

          # Check if we found any PRs
          total_entries=$(cat "$FEATURES_FILE" "$FIXES_FILE" "$DOCS_FILE" "$IMPROVEMENTS_FILE" "$OTHER_FILE" 2>/dev/null | wc -l)

          if [ "$total_entries" -eq 0 ]; then
            echo "No merged PRs found for changelog"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
            rm -f "$PROCESSED_PRS" "$FEATURES_FILE" "$FIXES_FILE" "$DOCS_FILE" "$IMPROVEMENTS_FILE" "$OTHER_FILE"
          else
            # Build changelog entry in a file
            CHANGELOG_ENTRY_FILE=$(mktemp)
            echo "## ${{ env.NEW_VERSION }} – ${RELEASE_DATE}" > "$CHANGELOG_ENTRY_FILE"

            if [ -s "$FEATURES_FILE" ]; then
              echo "" >> "$CHANGELOG_ENTRY_FILE"
              echo "### Added" >> "$CHANGELOG_ENTRY_FILE"
              cat "$FEATURES_FILE" >> "$CHANGELOG_ENTRY_FILE"
            fi

            if [ -s "$FIXES_FILE" ]; then
              echo "" >> "$CHANGELOG_ENTRY_FILE"
              echo "### Fixed" >> "$CHANGELOG_ENTRY_FILE"
              cat "$FIXES_FILE" >> "$CHANGELOG_ENTRY_FILE"
            fi

            if [ -s "$IMPROVEMENTS_FILE" ]; then
              echo "" >> "$CHANGELOG_ENTRY_FILE"
              echo "### Changed" >> "$CHANGELOG_ENTRY_FILE"
              cat "$IMPROVEMENTS_FILE" >> "$CHANGELOG_ENTRY_FILE"
            fi

            if [ -s "$DOCS_FILE" ]; then
              echo "" >> "$CHANGELOG_ENTRY_FILE"
              echo "### Documentation" >> "$CHANGELOG_ENTRY_FILE"
              cat "$DOCS_FILE" >> "$CHANGELOG_ENTRY_FILE"
            fi

            if [ -s "$OTHER_FILE" ]; then
              echo "" >> "$CHANGELOG_ENTRY_FILE"
              echo "### Other" >> "$CHANGELOG_ENTRY_FILE"
              cat "$OTHER_FILE" >> "$CHANGELOG_ENTRY_FILE"
            fi

            echo "" >> "$CHANGELOG_ENTRY_FILE"

            # Save changelog entry file path for next step
            echo "$CHANGELOG_ENTRY_FILE" > changelog_entry_path.txt

            # Clean up temp files (except the entry file)
            rm -f "$PRS_FILE" "$PROCESSED_PRS" "$FEATURES_FILE" "$FIXES_FILE" "$DOCS_FILE" "$IMPROVEMENTS_FILE" "$OTHER_FILE"

            echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
            echo "✓ Generated changelog entry for ${{ env.NEW_VERSION }} with $total_entries PR entries"
          fi

          echo "RELEASE_DATE=$RELEASE_DATE" >> $GITHUB_ENV

      # Stap 5: Update CHANGELOG.md met nieuwe entries
      - name: Update CHANGELOG.md
        if: steps.generate_changelog.outputs.HAS_CHANGES == 'true'
        run: |
          # Read changelog entry file path
          if [ -f "changelog_entry_path.txt" ]; then
            NEW_ENTRY_FILE=$(cat changelog_entry_path.txt)

            # Read current changelog and insert new entry
            if [ -f "CHANGELOG.md" ]; then
              # Insert new entry after "# Changelog" line and before first version entry
              awk -v new_entry_file="$NEW_ENTRY_FILE" '
                /^# Changelog$/ {
                  print
                  getline
                  if (/^$/) print
                  # Read and print new entry
                  while ((getline line < new_entry_file) > 0) {
                    print line
                  }
                  close(new_entry_file)
                  # Print the line we read (empty line or first version)
                  if (!/^$/) print
                  next
                }
                { print }
              ' CHANGELOG.md > CHANGELOG.md.tmp && mv CHANGELOG.md.tmp CHANGELOG.md
            else
              # Create new changelog file
              echo "# Changelog" > CHANGELOG.md
              echo "" >> CHANGELOG.md
              cat "$NEW_ENTRY_FILE" >> CHANGELOG.md
            fi

            # Clean up
            rm -f "$NEW_ENTRY_FILE" changelog_entry_path.txt
            echo "✓ CHANGELOG.md updated with version ${{ env.NEW_VERSION }}"
          else
            echo "Warning: changelog_entry_path.txt not found, skipping CHANGELOG.md update"
          fi

      # Stap 6: Update de versie in info.xml
      - name: Update version in info.xml
        run: |
          sed -i "s|<version>.*</version>|<version>${{ env.NEW_VERSION }}</version>|" appinfo/info.xml

      # Stap 7: Commit de nieuwe versie en changelog (indien er wijzigingen zijn)
      - name: Commit version update and changelog
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are changes to commit
          if git diff --quiet && git diff --cached --quiet; then
            echo "No changes to commit"
          else
            if [ "${{ steps.generate_changelog.outputs.HAS_CHANGES }}" == "true" ]; then
              git add CHANGELOG.md appinfo/info.xml
              git commit -m "Bump beta version to ${{ env.NEW_VERSION }} and update changelog [skip ci]"
            else
              git add appinfo/info.xml
              git commit -m "Bump beta version to ${{ env.NEW_VERSION }} [skip ci]"
            fi
            git push
          fi

      # Stap 6: Bereid de signing certificaten voor
      - name: Prepare Signing Certificate and Key
        run: |
          echo "${{ secrets.NEXTCLOUD_SIGNING_CERT }}" > signing-cert.crt
          echo "${{ secrets.NEXTCLOUD_SIGNING_KEY }}" > signing-key.key

      # Stap 7: Installeer npm dependencies
      - name: Install npm dependencies
        uses: actions/setup-node@v3
        with:
          node-version: '18.x'

      # Stap 8: Stel PHP in en installeer benodigde extensies
      - name: Set up PHP and install extensions
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.2'
          extensions: zip, gd

      # Stap 9: Voer npm install, build en composer install uit
      - run: npm ci
      - run: npm run build
      - run: composer install --no-dev --optimize-autoloader --classmap-authoritative

      # Stap 9a: Verify vendor dependencies are installed
      - name: Verify vendor dependencies
        run: |
          echo "Checking critical dependencies..."

          # Check that vendor directory exists and has content
          if [ ! -d "vendor" ] || [ -z "$(ls -A vendor 2>/dev/null)" ]; then
            echo "ERROR: vendor directory is missing or empty"
            exit 1
          fi

          # Check specific critical dependencies
          missing_deps=0

          if [ ! -d "vendor/openai-php/client/src" ]; then
            echo "ERROR: openai-php/client source files not found"
            missing_deps=1
          fi

          if [ ! -d "vendor/theodo-group/llphant/src" ]; then
            echo "ERROR: theodo-group/llphant source files not found"
            missing_deps=1
          fi

          if [ $missing_deps -eq 1 ]; then
            echo "HINT: Check composer.json dependencies and composer install output"
            exit 1
          fi

          echo "✓ All critical dependencies verified with source files"

      # Stap 10: Kopieer de bestanden naar de package directory
      - name: Copy the package files into the package
        run: |
          mkdir -p package/${{ github.event.repository.name }}
          rsync -av --progress \
            --exclude='/package' \
            --exclude='/.git' \
            --exclude='/.github' \
            --exclude='/.cursor' \
            --exclude='/.vscode' \
            --exclude='/.nextcloud' \
            --exclude='/docker' \
            --exclude='/docker-compose.yml' \
            --exclude='/docs' \
            --exclude='/website' \
            --exclude='/node_modules' \
            --exclude='/src' \
            --exclude='/phpcs-custom-sniffs' \
            --exclude='/resources' \
            --exclude='/tests' \
            --exclude='/path' \
            --exclude='/package.json' \
            --exclude='/package-lock.json' \
            --exclude='/composer.json' \
            --exclude='/composer.lock' \
            --exclude='/composer-setup.php' \
            --exclude='/phpcs.xml' \
            --exclude='/phpmd.xml' \
            --exclude='/psalm.xml' \
            --exclude='/phpunit.xml' \
            --exclude='/.phpunit.cache' \
            --exclude='.phpunit.result.cache' \
            --exclude='/jest.config.js' \
            --exclude='/webpack.config.js' \
            --exclude='/tsconfig.json' \
            --exclude='/.babelrc' \
            --exclude='/.eslintrc.js' \
            --exclude='/.prettierrc' \
            --exclude='/stylelint.config.js' \
            --exclude='/.spectral.yml' \
            --exclude='/.gitignore' \
            --exclude='/.gitattributes' \
            --exclude='/.php-cs-fixer.dist.php' \
            --exclude='/.nvmrc' \
            --exclude='/changelog-ci-config.json' \
            --exclude='/coverage.txt' \
            --exclude='/signing-key.key' \
            --exclude='/signing-cert.crt' \
            --exclude='/openapi.json' \
            --exclude='/*_ANALYSIS.md' \
            --exclude='/*_FIX.md' \
            --exclude='/*_SUMMARY.md' \
            --exclude='/*_GUIDE.md' \
            ./ package/${{ github.event.repository.name }}/

      # Stap 11: Verify package contents before creating tarball
      - name: Verify package vendor directory
        run: |
          echo "Verifying package contains complete vendor dependencies..."

          # Check vendor directory was copied
          if [ ! -d "package/${{ github.event.repository.name }}/vendor" ]; then
            echo "ERROR: vendor directory not found in package"
            exit 1
          fi

          # Verify vendor packages have source files (not just LICENSE)
          if [ ! -d "package/${{ github.event.repository.name }}/vendor/openai-php/client/src" ]; then
            echo "ERROR: openai-php/client/src not found in package"
            echo "HINT: Check rsync exclusion patterns - they may be too broad"
            ls -la package/${{ github.event.repository.name }}/vendor/openai-php/client/ || true
            exit 1
          fi

          # Quick sanity check: count vendor subdirectories
          vendor_count=$(find package/${{ github.event.repository.name }}/vendor -maxdepth 1 -type d | wc -l)
          if [ $vendor_count -lt 10 ]; then
            echo "WARNING: Only $vendor_count vendor directories found (expected 20+)"
            echo "Listing vendor contents:"
            ls -la package/${{ github.event.repository.name }}/vendor/
          fi

          echo "✓ Package vendor directory verified with source files"

      # Stap 12: Maak het TAR.GZ archief
      - name: Create Tarball
        run: |
          cd package && tar -czf ../nextcloud-release.tar.gz ${{ github.event.repository.name }}

      # Stap 13: Sign het TAR.GZ bestand met OpenSSL
      - name: Sign the TAR.GZ file with OpenSSL
        run: |
          openssl dgst -sha512 -sign signing-key.key nextcloud-release.tar.gz | openssl base64 -out nextcloud-release.signature

      # Stap 13a: Upload tarball as workflow artifact for easy inspection
      - name: Upload tarball as artifact
        uses: actions/upload-artifact@v4
        with:
          name: nextcloud-release-${{ env.NEW_VERSION }}
          path: |
            nextcloud-release.tar.gz
            nextcloud-release.signature
          retention-days: 30

      # Stap 14: Genereer Git versie informatie (optioneel, voor logging)
      - name: Git Version
        id: version
        uses: codacy/git-version@2.7.1
        with:
          release-branch: beta

      # Stap 15: Extraheer repository description (optioneel)
      - name: Extract repository description
        id: repo-description
        run: |
          description=$(jq -r '.description' <(curl -s https://api.github.com/repos/${{ github.repository }}))
          echo "REPO_DESCRIPTION=$description" >> $GITHUB_ENV

      # Stap 16: Output de versie (voor logging)
      - name: Use the version
        run: |
          echo "Git Version info: ${{ steps.version.outputs.version }}"

      # Stap 17: Maak een nieuwe GitHub release (als prerelease)
      - name: Upload Beta Release
        uses: ncipollo/release-action@v1.12.0
        with:
          tag: v${{ env.NEW_VERSION }}
          name: Beta Release ${{ env.NEW_VERSION }}
          draft: false
          prerelease: true
          skipIfReleaseExists: true

      # Stap 18: Voeg het tarball toe als asset aan de GitHub release
      - name: Attach tarball to GitHub release
        uses: svenstaro/upload-release-action@v2
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: nextcloud-release.tar.gz
          asset_name: ${{ env.APP_NAME }}-${{ env.NEW_VERSION }}.tar.gz
          tag: v${{ env.NEW_VERSION }}
          overwrite: true

      # Stap 19: Upload de app naar de Nextcloud App Store
      - name: Upload app to Nextcloud appstore
        uses: nextcloud-releases/nextcloud-appstore-push-action@a011fe619bcf6e77ddebc96f9908e1af4071b9c1
        with:
          app_name: ${{ env.APP_NAME }}
          appstore_token: ${{ secrets.NEXTCLOUD_APPSTORE_TOKEN }}
          download_url: https://github.com/${{ github.repository }}/releases/download/v${{ env.NEW_VERSION }}/${{ env.APP_NAME }}-${{ env.NEW_VERSION }}.tar.gz
          app_private_key: ${{ secrets.NEXTCLOUD_SIGNING_KEY }}
          nightly: false

      # Stap 20: Verifieer de release
      - name: Verify version and contents
        run: |
          echo "App version: ${{ env.NEW_VERSION }}"
          echo "Tarball contents:"
          tar -tvf nextcloud-release.tar.gz | head -100
          echo "Verify vendor directory in tarball:"
          tar -tvf nextcloud-release.tar.gz | grep "vendor/openai-php/client" | head -5 || echo "WARNING: openai-php/client not found in tarball!"
          echo "info.xml contents:"
          tar -xOf nextcloud-release.tar.gz ${{ env.APP_NAME }}/appinfo/info.xml
